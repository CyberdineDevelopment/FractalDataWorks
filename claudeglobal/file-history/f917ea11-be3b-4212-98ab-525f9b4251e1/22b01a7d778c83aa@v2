using System;
using System.Collections.Generic;
using System.Linq;
using FractalDataWorks.CodeBuilder.Abstractions;
using FractalDataWorks.CodeBuilder.CSharp.Builders;
using FractalDataWorks.SourceGenerators.Configuration;
using FractalDataWorks.SourceGenerators.Models;

namespace FractalDataWorks.SourceGenerators.Generators;

/// <summary>
/// Generates fields for collection classes.
/// Responsible for creating static value fields, lookup dictionaries, and internal fields.
/// </summary>
public sealed class FieldGenerator
{
    private readonly CollectionBuilderConfiguration _config;

    /// <summary>
    /// Initializes a new instance of the <see cref="FieldGenerator"/> class.
    /// </summary>
    /// <param name="config">The collection builder configuration.</param>
    public FieldGenerator(CollectionBuilderConfiguration config)
    {
        _config = config ?? throw new ArgumentNullException(nameof(config));
    }

    /// <summary>
    /// Adds static readonly fields for each collection value.
    /// </summary>
    public void AddStaticFields(IClassBuilder classBuilder, IList<GenericValueInfoModel> values, string returnType)
    {
        if (classBuilder == null) throw new ArgumentNullException(nameof(classBuilder));
        if (values == null) throw new ArgumentNullException(nameof(values));

        foreach (var value in values)
        {
            var fieldName = value.Name;
            var initializer = GenerateValueInitializer(value);

            var field = new FieldBuilder()
                .WithName(fieldName)
                .WithType(returnType)
                .WithAccessModifier("public")
                .AsStatic()
                .AsReadOnly()
                .WithInitializer(initializer)
                .WithXmlDoc($"Gets the {value.Name} instance.");

            classBuilder.WithField(field);
        }
    }

    /// <summary>
    /// Adds the private static readonly _empty field.
    /// </summary>
    public void AddEmptyField(IClassBuilder classBuilder, string returnType, string emptyClassName)
    {
        if (classBuilder == null) throw new ArgumentNullException(nameof(classBuilder));

        var emptyField = new FieldBuilder()
            .WithName("_empty")
            .WithType(returnType)
            .WithAccessModifier("private")
            .AsStatic()
            .AsReadOnly()
            .WithInitializer($"new {emptyClassName}()")
            .WithXmlDoc("Static empty instance with default values.");

        classBuilder.WithField(emptyField);
    }

    /// <summary>
    /// Adds the private static readonly _all FrozenDictionary field.
    /// </summary>
    public void AddAllDictionaryField(IClassBuilder classBuilder, string returnType)
    {
        if (classBuilder == null) throw new ArgumentNullException(nameof(classBuilder));

        var allField = new FieldBuilder()
            .WithName("_all")
            .WithType($"FrozenDictionary<int, {returnType}>")
            .WithAccessModifier("private")
            .AsStatic()
            .AsReadOnly()
            .WithXmlDoc("Primary dictionary for ID-based lookups using FrozenDictionary for O(1) performance.");

        classBuilder.WithField(allField);
    }

    /// <summary>
    /// Adds lookup dictionary fields with conditional compilation for NET8_0_OR_GREATER.
    /// For netstandard2.0: separate _byName, _byXXX dictionaries
    /// For NET8+: uses GetAlternateLookup on _all dictionary
    /// </summary>
    public void AddDynamicLookupFields(IClassBuilder classBuilder, IList<PropertyLookupInfoModel> lookupProperties, string returnType)
    {
        if (classBuilder == null) throw new ArgumentNullException(nameof(classBuilder));
        if (lookupProperties == null) return;

        var nonIdLookups = lookupProperties
            .Where(l => !string.Equals(l.PropertyName, "Id", StringComparison.Ordinal) || !string.Equals(l.PropertyType, "int", StringComparison.Ordinal))
            .ToList();

        if (nonIdLookups.Count == 0)
            return;

        // Add first field with #if directive
        var firstLookup = nonIdLookups[0];
        var firstFieldName = $"_by{firstLookup.PropertyName}";
        var firstFieldType = $"FrozenDictionary<{firstLookup.PropertyType}, {returnType}>";

        var firstLookupField = new FieldBuilder()
            .WithName(firstFieldName)
            .WithType(firstFieldType)
            .WithAccessModifier("private")
            .AsStatic()
            .AsReadOnly()
            .WithXmlDoc($"Lookup dictionary for {firstLookup.PropertyName}-based searches (netstandard2.0 only).")
            .WithPreprocessorDirective("if !NET8_0_OR_GREATER");

        classBuilder.WithField(firstLookupField);

        // Add remaining fields without directives
        for (int i = 1; i < nonIdLookups.Count; i++)
        {
            var lookup = nonIdLookups[i];
            var fieldName = $"_by{lookup.PropertyName}";
            var fieldType = $"FrozenDictionary<{lookup.PropertyType}, {returnType}>";

            var lookupField = new FieldBuilder()
                .WithName(fieldName)
                .WithType(fieldType)
                .WithAccessModifier("private")
                .AsStatic()
                .AsReadOnly()
                .WithXmlDoc($"Lookup dictionary for {lookup.PropertyName}-based searches (netstandard2.0 only).");

            classBuilder.WithField(lookupField);
        }

        // Add a dummy field with #endif to close the block
        var endifField = new FieldBuilder()
            .WithName("_preprocessorEnd")
            .WithType("int")
            .WithAccessModifier("private")
            .AsStatic()
            .AsReadOnly()
            .WithInitializer("0")
            .WithPreprocessorDirective("endif");

        classBuilder.WithField(endifField);
    }

    /// <summary>
    /// Generates the initializer expression for a value field.
    /// </summary>
    private static string GenerateValueInitializer(GenericValueInfoModel value)
    {
        if (value == null) return "default!";

        if (value.IsAbstract)
        {
            return $"null!  // {value.Name} is abstract - cannot be instantiated";
        }

        if (value.Constructor == null || value.Constructor.Parameters == null || value.Constructor.Parameters.Count == 0)
        {
            return $"new {value.Name}()";
        }

        var args = string.Join(", ", value.Constructor.Parameters.Select(p =>
        {
            if (!string.IsNullOrEmpty(p.DefaultValue))
                return p.DefaultValue;

            return p.Type switch
            {
                "string" => "string.Empty",
                "int" => "0",
                "long" => "0L",
                "Guid" => "Guid.Empty",
                _ => "default"
            };
        }));

        return $"new {value.Name}({args})";
    }
}
