using System;
using System.Collections.Generic;
using System.Linq;
using FractalDataWorks.CodeBuilder.Abstractions;
using FractalDataWorks.CodeBuilder.CSharp.Builders;
using FractalDataWorks.SourceGenerators.Configuration;
using FractalDataWorks.SourceGenerators.Models;

namespace FractalDataWorks.SourceGenerators.Generators;

/// <summary>
/// Generates field declarations for collection classes.
/// Responsible for creating _all, _empty, and lookup dictionary fields.
/// </summary>
public sealed class FieldGenerator
{
    private readonly CollectionBuilderConfiguration _config;

    public FieldGenerator(CollectionBuilderConfiguration config)
    {
        _config = config ?? throw new ArgumentNullException(nameof(config));
    }

    /// <summary>
    /// Generates the _all static field (FrozenDictionary or Dictionary based on target).
    /// </summary>
    public IFieldBuilder GenerateAllField(string returnType)
    {
        return new FieldBuilder()
            .WithName("_all")
            .WithType($"FrozenDictionary<int, {returnType}>")
            .WithAccessModifier("private")
            .AsStatic()
            .AsReadOnly()
            .WithXmlDoc("Primary lookup dictionary for all collection items, keyed by ID.");
    }

    /// <summary>
    /// Generates the _empty static field.
    /// </summary>
    public IFieldBuilder GenerateEmptyField(string returnType, string emptyClassName)
    {
        return new FieldBuilder()
            .WithName("_empty")
            .WithType(returnType)
            .WithAccessModifier("private")
            .AsStatic()
            .AsReadOnly()
            .WithInitializer($"new {emptyClassName}()")
            .WithXmlDoc("Static empty instance with default values.");
    }

    /// <summary>
    /// Generates lookup dictionary fields for non-ID properties (e.g., _byName).
    /// Uses conditional compilation to only generate for netstandard2.0.
    /// </summary>
    public List<IFieldBuilder> GenerateLookupDictionaryFields(
        GenericTypeInfoModel definition,
        string returnType)
    {
        var fields = new List<IFieldBuilder>();

        if (definition?.LookupProperties == null)
            return fields;

        var nonIdLookups = definition.LookupProperties
            .Where(l => !string.Equals(l.PropertyName, "Id", StringComparison.Ordinal) ||
                       !string.Equals(l.PropertyType, "int", StringComparison.Ordinal))
            .ToList();

        if (nonIdLookups.Count == 0)
            return fields;

        // First field gets #if directive
        var firstLookup = nonIdLookups[0];
        var firstField = new FieldBuilder()
            .WithName($"_by{firstLookup.PropertyName}")
            .WithType($"FrozenDictionary<{firstLookup.PropertyType}, {returnType}>")
            .WithAccessModifier("private")
            .AsStatic()
            .AsReadOnly()
            .WithXmlDoc($"Lookup dictionary for {firstLookup.PropertyName}-based searches (netstandard2.0 only).")
            .WithPreprocessorDirective("if !NET8_0_OR_GREATER");

        fields.Add(firstField);

        // Remaining fields without directives
        for (int i = 1; i < nonIdLookups.Count; i++)
        {
            var lookup = nonIdLookups[i];
            var field = new FieldBuilder()
                .WithName($"_by{lookup.PropertyName}")
                .WithType($"FrozenDictionary<{lookup.PropertyType}, {returnType}>")
                .WithAccessModifier("private")
                .AsStatic()
                .AsReadOnly()
                .WithXmlDoc($"Lookup dictionary for {lookup.PropertyName}-based searches (netstandard2.0 only).");

            fields.Add(field);
        }

        // Add dummy field with #endif
        var endifField = new FieldBuilder()
            .WithName("_preprocessorEnd")
            .WithType("int")
            .WithAccessModifier("private")
            .AsStatic()
            .AsReadOnly()
            .WithInitializer("0")
            .WithPreprocessorDirective("endif");

        fields.Add(endifField);

        return fields;
    }

    /// <summary>
    /// Generates static fields for enum values (field-per-value pattern).
    /// </summary>
    public List<IFieldBuilder> GenerateValueFields(
        IList<GenericValueInfoModel> values,
        string returnType)
    {
        var fields = new List<IFieldBuilder>();

        foreach (var value in values)
        {
            // Skip abstract types - they can't be instantiated
            if (value.IsAbstract)
                continue;

            var field = new FieldBuilder()
                .WithName(value.Name)
                .WithType(returnType)
                .WithAccessModifier("public")
                .AsStatic()
                .AsReadOnly()
                .WithXmlDoc($"Gets the {value.Name} instance.");

            fields.Add(field);
        }

        return fields;
    }
}
