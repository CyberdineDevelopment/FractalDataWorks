using System;
using System.Collections.Generic;
using System.Text;
using Microsoft.CodeAnalysis;
using FractalDataWorks.CodeBuilder.CSharp.Builders;
using FractalDataWorks.SourceGenerators.Configuration;
using FractalDataWorks.SourceGenerators.Generators;
using FractalDataWorks.SourceGenerators.Models;
using FractalDataWorks.SourceGenerators.Services;

namespace FractalDataWorks.SourceGenerators.Builders;

/// <summary>
/// Orchestrates the generation of collection classes using specialized generators.
/// This class follows the Single Responsibility Principle by delegating to focused generators.
/// </summary>
public sealed class GenericCollectionBuilder : IGenericCollectionBuilder
{
    private readonly CollectionBuilderConfiguration _config;
    private readonly FieldGenerator _fieldGenerator;
    private readonly LookupMethodGenerator _lookupMethodGenerator;
    private readonly EmptyClassGenerator _emptyClassGenerator;

    private CollectionGenerationMode _mode;
    private GenericTypeInfoModel? _definition;
    private IList<GenericValueInfoModel>? _values;
    private string? _returnType;
    private Compilation? _compilation;

    public GenericCollectionBuilder(CollectionBuilderConfiguration config)
    {
        _config = config ?? throw new ArgumentNullException(nameof(config));
        _config.Validate();

        // Initialize generators
        _fieldGenerator = new FieldGenerator(config);
        _lookupMethodGenerator = new LookupMethodGenerator(config);
        _emptyClassGenerator = new EmptyClassGenerator(config);
    }

    public IGenericCollectionBuilder Configure(CollectionGenerationMode mode)
    {
        _mode = mode;
        return this;
    }

    public IGenericCollectionBuilder WithDefinition(GenericTypeInfoModel definition)
    {
        _definition = definition ?? throw new ArgumentNullException(nameof(definition));
        return this;
    }

    public IGenericCollectionBuilder WithValues(IList<GenericValueInfoModel> values)
    {
        _values = values ?? throw new ArgumentNullException(nameof(values));
        return this;
    }

    public IGenericCollectionBuilder WithReturnType(string returnType)
    {
        if (string.IsNullOrEmpty(returnType))
            throw new ArgumentException("Return type cannot be null or empty.", nameof(returnType));

        _returnType = returnType;
        return this;
    }

    public IGenericCollectionBuilder WithCompilation(Compilation compilation)
    {
        _compilation = compilation ?? throw new ArgumentNullException(nameof(compilation));
        return this;
    }

    public string Build()
    {
        ValidateConfiguration();

        var classBuilder = new ClassBuilder()
            .WithNamespace(_definition!.Namespace)
            .WithName(_definition.CollectionName)
            .WithAccessModifier("public")
            .AsPartial()
            .AsStatic();

        // Add using directives
        classBuilder.WithUsings("System", "System.Collections.Generic", "System.Collections.Frozen");

        // Generate empty class name
        var emptyClassName = $"Empty{_returnType}";

        // Generate fields using FieldGenerator
        var allField = _fieldGenerator.GenerateAllField(_returnType!);
        classBuilder.WithField(allField);

        var emptyField = _fieldGenerator.GenerateEmptyField(_returnType!, emptyClassName);
        classBuilder.WithField(emptyField);

        // Generate lookup dictionary fields (with conditional compilation)
        var lookupFields = _fieldGenerator.GenerateLookupDictionaryFields(_definition!, _returnType!);
        foreach (var field in lookupFields)
        {
            classBuilder.WithField(field);
        }

        // Generate lookup methods using LookupMethodGenerator
        var lookupMethods = _lookupMethodGenerator.GenerateDynamicLookupMethods(_definition!, _returnType!);
        foreach (var method in lookupMethods)
        {
            classBuilder.WithMethod(method);
        }

        // Generate All() method
        var allMethod = new MethodBuilder()
            .WithName("All")
            .WithReturnType($"IReadOnlyList<{_returnType}>")
            .WithAccessModifier("public")
            .AsStatic()
            .WithExpressionBody("_all.Values.ToList()")
            .WithXmlDoc("Gets all collection items.")
            .WithReturnDoc("A read-only list of all items in the collection.");

        classBuilder.WithMethod(allMethod);

        // Build the class
        return classBuilder.Build();
    }

    /// <summary>
    /// Gets the generated Empty class code.
    /// </summary>
    public string GetEmptyClassCode()
    {
        if (_definition == null || _returnType == null)
            return string.Empty;

        return _emptyClassGenerator.GenerateEmptyClass(
            _definition,
            _returnType,
            _definition.Namespace);
    }

    private void ValidateConfiguration()
    {
        if (_definition == null)
            throw new InvalidOperationException("Definition must be set before building.");

        if (_values == null)
            throw new InvalidOperationException("Values must be set before building.");

        if (string.IsNullOrEmpty(_returnType))
            throw new InvalidOperationException("Return type must be set before building.");

        if (_compilation == null)
            throw new InvalidOperationException("Compilation must be set before building.");
    }
}
