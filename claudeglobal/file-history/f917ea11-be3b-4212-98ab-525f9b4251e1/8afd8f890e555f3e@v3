using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using FractalDataWorks.ServiceTypes.SourceGenerators.Models;
using FractalDataWorks.SourceGenerators.Models;
using FractalDataWorks.SourceGenerators.Services;
using FractalDataWorks.SourceGenerators.Builders;
using FractalDataWorks.SourceGenerators.Configuration;

namespace FractalDataWorks.ServiceTypes.SourceGenerators.Generators;

/// <summary>
/// ServiceTypeCollectionGenerator - Specialized generator for ServiceType collections.
/// 
/// DISCOVERY STRATEGY:
/// - Looks for classes that inherit from ServiceTypeCollectionBase&lt;TBase,TGeneric,TService,TConfiguration,TFactory&gt;
/// - Uses inheritance-based detection (no attributes required)
/// - Global assembly scanning for comprehensive service discovery
/// - Generates high-performance collections with FrozenDictionary support
/// 
/// NAMING CONVENTION:
/// - ConnectionTypeCollectionBase -&gt; generates ConnectionTypes (removes "CollectionBase" suffix)
/// - Uses the collection class's namespace
/// - Creates partial class for the generated name
/// 
/// GENERATED API:
/// - ConnectionTypes.All() -&gt; IReadOnlyList&lt;ConnectionTypeBase&gt;
/// - ConnectionTypes.Empty() -> EmptyConnectionType instance
/// - ConnectionTypes.Name(string) / Id(int) -> lookup with _empty fallback
/// - ConnectionTypes.GetByServiceType/ConfigurationType/SectionName -> attribute-based lookups
/// - ConnectionTypes.Create{TypeName}() -&gt; factory methods for each constructor
/// </summary>
[Generator]
public sealed class ServiceTypeCollectionGenerator : IIncrementalGenerator
{
    private static readonly DiagnosticDescriptor AbstractPropertyInBaseTypeRule = new(
        id: "ST006",
        title: "Abstract properties not allowed in ServiceType base types",
        messageFormat: "The base type '{0}' contains abstract property '{1}'. ServiceType base types must not have abstract properties - use constructor parameters to pass property values instead.",
        category: "ServiceTypes",
        DiagnosticSeverity.Error,
        isEnabledByDefault: true,
        description: "ServiceType base types should only have abstract methods, not abstract properties. All properties should be set via constructor parameters.");
    /// <summary>
    /// Initializes the incremental generator for ServiceType collections with optimized attribute-based discovery.
    /// </summary>
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Use optimized attribute-based discovery instead of global scanning
        var serviceTypeCollectionsProvider = context.CompilationProvider
            .Select(static (compilation, token) => 
            {
                token.ThrowIfCancellationRequested();
                return DiscoverServiceTypeCollectionsOptimized(compilation);
            });

        context.RegisterSourceOutput(serviceTypeCollectionsProvider, static (context, results) =>
        {
            foreach (var result in results)
            {
                // Report any diagnostics first
                foreach (var diagnostic in result.Diagnostics)
                {
                    context.ReportDiagnostic(diagnostic);
                }

                // Only generate code if there are no error diagnostics
                if (!result.Diagnostics.Any(d => d.Severity == DiagnosticSeverity.Error))
                {
                    Execute(context, result.ServiceTypeInfoModel, result.Compilation, result.DiscoveredServiceTypes, result.CollectionClass);
                }
            }
        });
    }

    /// <summary>
    /// Validates that the base type doesn't contain abstract properties.
    /// Returns diagnostics for any abstract properties found.
    /// </summary>
    private static List<Diagnostic> ValidateNoAbstractProperties(INamedTypeSymbol baseType, INamedTypeSymbol collectionClass)
    {
        var diagnostics = new List<Diagnostic>();
        var current = baseType;

        // Walk up the inheritance chain looking for abstract properties
        while (current != null)
        {
            foreach (var member in current.GetMembers())
            {
                if (member is IPropertySymbol property && property.IsAbstract)
                {
                    // Get the location of the abstract property itself
                    var propertyLocation = property.Locations.FirstOrDefault();

                    // If we can't get the property location, fall back to the attribute location
                    if (propertyLocation == null || propertyLocation.IsInMetadata)
                    {
                        propertyLocation = collectionClass.GetAttributes()
                            .FirstOrDefault(a => a.AttributeClass?.Name == "ServiceTypeCollectionAttribute")
                            ?.ApplicationSyntaxReference?.GetSyntax().GetLocation();
                    }

                    if (propertyLocation != null)
                    {
                        var diagnostic = Diagnostic.Create(
                            AbstractPropertyInBaseTypeRule,
                            propertyLocation,
                            baseType.ToDisplayString(),
                            property.Name);

                        diagnostics.Add(diagnostic);
                    }
                }
            }
            current = current.BaseType;
        }

        return diagnostics;
    }

    /// <summary>
    /// PHASE 1-6: Complete discovery and model building (ULTRA-OPTIMIZED)
    /// Discovers all collection definitions using ServiceTypeOption-first discovery for maximum performance.
    /// </summary>
    private static ImmutableArray<ServiceTypeInfoWithCompilation> DiscoverServiceTypeCollectionsOptimized(Compilation compilation)
    {
        var results = new List<ServiceTypeInfoWithCompilation>();

        // STEP 1: ULTRA-OPTIMIZED ServiceTypeOption Discovery First
        // O(types_with_servicetypeoption) with explicit collection targeting
        var serviceOptionsByCollectionType = FindAndGroupAllServiceTypeOptions(compilation);

        // STEP 2: OPTIMIZED Collection Class Discovery using ServiceTypeCollectionAttribute
        // O(k) attribute filtering for collection classes
        var attributedCollectionClasses = FindAttributedCollectionClasses(compilation);

        // STEP 3-6: For each attributed collection class, lookup pre-discovered service type options
        foreach (var (collectionClass, attribute) in attributedCollectionClasses)
        {
            // STEP 3: Base Type Resolution from Attribute
            var baseTypeName = ExtractBaseTypeNameFromAttribute(attribute);
            if (string.IsNullOrEmpty(baseTypeName)) continue;

            var baseType = compilation.GetTypeByMetadataName(baseTypeName!);
            if (baseType == null) continue;

            // STEP 3.1: Validate base type doesn't have abstract properties
            var diagnostics = ValidateNoAbstractProperties(baseType, collectionClass);

            // STEP 4: ULTRA-FAST Option Type Lookup (O(1) dictionary lookup)
            // FIX: Lookup pre-discovered options by collection class, not base type
            if (!serviceOptionsByCollectionType.TryGetValue(collectionClass, out var serviceTypesList))
            {
                serviceTypesList = new List<INamedTypeSymbol>();
            }
            var serviceTypes = serviceTypesList.ToImmutableArray();

            // STEP 5: Model Building and Validation
            // Create ServiceTypeInfoModel with discovered types (always generate for Empty() support)
            if (serviceTypes.Length > 0 || true)
            {
                // STEP 6: Definition Construction with Attribute Data
                var typeDefinition = BuildServiceTypeCollectionDefinitionFromAttributedCollection(collectionClass, baseType, serviceTypesList, compilation, attribute);
                if (typeDefinition != null)
                {
                    // STEP 7: Final Assembly (include diagnostics)
                    results.Add(new ServiceTypeInfoWithCompilation(typeDefinition, compilation, serviceTypes, collectionClass, diagnostics));
                }
            }
        }

        return [..results];
    }

    /// <summary>
    /// STEP 1.1: ULTRA-OPTIMIZED ServiceTypeOption Discovery and Grouping
    /// Single pass through all assemblies to find [ServiceTypeOption] attributes and group by explicit collection type.
    /// O(types_with_servicetypeoption) with explicit collection targeting for maximum performance.
    /// </summary>
    private static Dictionary<INamedTypeSymbol, List<INamedTypeSymbol>> FindAndGroupAllServiceTypeOptions(Compilation compilation)
    {
        var serviceOptionsByCollectionType = new Dictionary<INamedTypeSymbol, List<INamedTypeSymbol>>(SymbolEqualityComparer.Default);
        var serviceTypeOptionAttributeType = compilation.GetTypeByMetadataName(typeof(FractalDataWorks.ServiceTypes.Attributes.ServiceTypeOptionAttribute).FullName!);

        if (serviceTypeOptionAttributeType == null) return serviceOptionsByCollectionType;

        // Single pass: scan all assemblies for [ServiceTypeOption] attributes
        var allServiceOptionsWithAttributes = new List<(INamedTypeSymbol Type, AttributeData Attribute)>();

        // Scan current compilation
        ScanNamespaceForServiceTypeOptionsWithAttributes(compilation.GlobalNamespace, serviceTypeOptionAttributeType, allServiceOptionsWithAttributes);

        // Scan all referenced assemblies
        foreach (var reference in compilation.References)
        {
            if (compilation.GetAssemblyOrModuleSymbol(reference) is IAssemblySymbol assemblySymbol)
            {
                ScanNamespaceForServiceTypeOptionsWithAttributes(assemblySymbol.GlobalNamespace, serviceTypeOptionAttributeType, allServiceOptionsWithAttributes);
            }
        }

        // Group discovered ServiceTypeOption types by their explicit collection type
        // Use dictionary to track most derived type for each unique type name
        var typesByCollectionAndName = new Dictionary<INamedTypeSymbol, Dictionary<string, INamedTypeSymbol>>(SymbolEqualityComparer.Default);

        foreach (var (serviceOptionType, attribute) in allServiceOptionsWithAttributes)
        {
            var collectionType = ExtractCollectionTypeFromServiceTypeOptionAttribute(attribute, compilation);
            if (collectionType != null)
            {
                if (!typesByCollectionAndName.TryGetValue(collectionType, out var typesByName))
                {
                    typesByName = new Dictionary<string, INamedTypeSymbol>(StringComparer.Ordinal);
                    typesByCollectionAndName[collectionType] = typesByName;
                }

                var fullTypeName = serviceOptionType.ToDisplayString();

                // If we've seen this type name before, keep the most derived version
                if (typesByName.TryGetValue(fullTypeName, out var existingType))
                {
                    // Check if serviceOptionType is more derived than existingType
                    if (IsDerivedFrom(serviceOptionType, existingType))
                    {
                        typesByName[fullTypeName] = serviceOptionType;
                    }
                    // If existingType is more derived, keep it (do nothing)
                }
                else
                {
                    // First time seeing this type name
                    typesByName[fullTypeName] = serviceOptionType;
                }
            }
        }

        // Convert back to the expected format
        foreach (var kvp in typesByCollectionAndName)
        {
            var list = kvp.Value.Values.ToList();
            serviceOptionsByCollectionType[kvp.Key] = list;
        }

        return serviceOptionsByCollectionType;
    }

    /// <summary>
    /// Checks if candidateType is derived from baseType.
    /// </summary>
    private static bool IsDerivedFrom(INamedTypeSymbol candidateType, INamedTypeSymbol baseType)
    {
        var current = candidateType.BaseType;
        while (current != null)
        {
            if (SymbolEqualityComparer.Default.Equals(current, baseType))
            {
                return true;
            }
            current = current.BaseType;
        }
        return false;
    }

    /// <summary>
    /// Helper method to recursively scan namespaces for ServiceTypeOption attributes with attribute data.
    /// </summary>
    private static void ScanNamespaceForServiceTypeOptionsWithAttributes(INamespaceSymbol namespaceSymbol, INamedTypeSymbol serviceTypeOptionAttributeType, List<(INamedTypeSymbol Type, AttributeData Attribute)> results)
    {
        // Scan types in current namespace
        foreach (var type in namespaceSymbol.GetTypeMembers())
        {
            var attribute = GetServiceTypeOptionAttribute(type, serviceTypeOptionAttributeType);
            if (attribute != null)
            {
                results.Add((type, attribute));
            }

            // Recursively scan nested types
            ScanNestedTypesForServiceTypeOptionWithAttributes(type, serviceTypeOptionAttributeType, results);
        }

        // Recursively scan child namespaces
        foreach (var childNamespace in namespaceSymbol.GetNamespaceMembers())
        {
            ScanNamespaceForServiceTypeOptionsWithAttributes(childNamespace, serviceTypeOptionAttributeType, results);
        }
    }

    /// <summary>
    /// Helper method to scan nested types for ServiceTypeOption attributes with attribute data.
    /// </summary>
    private static void ScanNestedTypesForServiceTypeOptionWithAttributes(INamedTypeSymbol parentType, INamedTypeSymbol serviceTypeOptionAttributeType, List<(INamedTypeSymbol Type, AttributeData Attribute)> results)
    {
        foreach (var nestedType in parentType.GetTypeMembers())
        {
            var attribute = GetServiceTypeOptionAttribute(nestedType, serviceTypeOptionAttributeType);
            if (attribute != null)
            {
                results.Add((nestedType, attribute));
            }

            // Recursively scan deeper nested types
            ScanNestedTypesForServiceTypeOptionWithAttributes(nestedType, serviceTypeOptionAttributeType, results);
        }
    }

    /// <summary>
    /// Gets the ServiceTypeOption attribute from a type if it exists.
    /// </summary>
    private static AttributeData? GetServiceTypeOptionAttribute(INamedTypeSymbol type, INamedTypeSymbol serviceTypeOptionAttributeType)
    {
        return type.GetAttributes()
            .FirstOrDefault(attr => SymbolEqualityComparer.Default.Equals(attr.AttributeClass, serviceTypeOptionAttributeType));
    }

    /// <summary>
    /// Extracts the collection type from a ServiceTypeOption attribute.
    /// </summary>
    private static INamedTypeSymbol? ExtractCollectionTypeFromServiceTypeOptionAttribute(AttributeData attribute, Compilation compilation)
    {
        // The first constructor argument should be the collection type
        if (attribute.ConstructorArguments.Length >= 1)
        {
            var collectionTypeArg = attribute.ConstructorArguments[0];
            if (collectionTypeArg.Value is INamedTypeSymbol collectionType)
            {
                return collectionType;
            }
        }
        return null;
    }

    /// <summary>
    /// Finds the immediate base type that this ServiceTypeOption type inherits from (used for grouping).
    /// Only looks for concrete base types that could be collection targets.
    /// </summary>
    private static INamedTypeSymbol? FindImmediateCollectionBaseType(INamedTypeSymbol serviceOptionType)
    {
        var currentType = serviceOptionType.BaseType;

        // Walk up inheritance chain to find the first non-object, non-abstract base type
        // This should be the collection base type (e.g., ConnectionTypeBase, ProcessStateBase, etc.)
        while (currentType != null)
        {
            // Stop at object
            if (currentType.SpecialType == SpecialType.System_Object)
                break;

            // If we find a concrete base type, that's likely our collection base
            if (!currentType.IsAbstract)
            {
                return currentType;
            }

            // If we find an abstract base that ends with "Base" or "Type", that's probably our target
            if (currentType.Name.EndsWith("Base", StringComparison.Ordinal) ||
                currentType.Name.EndsWith("Type", StringComparison.Ordinal))
            {
                return currentType;
            }

            currentType = currentType.BaseType;
        }

        return null;
    }

    /// <summary>
    /// STEP 1.2: OPTIMIZED Collection Class Discovery using ServiceTypeCollectionAttribute
    /// O(k) attribute filtering instead of O(n√óm) inheritance scanning.
    /// </summary>
    private static List<(INamedTypeSymbol CollectionClass, AttributeData Attribute)> FindAttributedCollectionClasses(Compilation compilation)
    {
        var results = new List<(INamedTypeSymbol CollectionClass, AttributeData Attribute)>();
        var attributeType = compilation.GetTypeByMetadataName("FractalDataWorks.ServiceTypes.Attributes.ServiceTypeCollectionAttribute");

        if (attributeType == null) return results;

        // Only scan current compilation namespace - not all references
        ScanNamespaceForAttributedClasses(compilation.GlobalNamespace, attributeType, results);

        return results;
    }

    /// <summary>
    /// Recursively scans namespace hierarchy for classes with ServiceTypeCollectionAttribute.
    /// </summary>
    private static void ScanNamespaceForAttributedClasses(
        INamespaceSymbol namespaceSymbol,
        INamedTypeSymbol attributeType,
        List<(INamedTypeSymbol CollectionClass, AttributeData Attribute)> results)
    {
        // Check types in current namespace
        foreach (var type in namespaceSymbol.GetTypeMembers())
        {
            var attributeData = type.GetAttributes()
                .FirstOrDefault(a => SymbolEqualityComparer.Default.Equals(a.AttributeClass, attributeType));
            
            if (attributeData != null)
            {
                results.Add((type, attributeData));
            }
        }

        // Recursively scan child namespaces
        foreach (var childNamespace in namespaceSymbol.GetNamespaceMembers())
        {
            ScanNamespaceForAttributedClasses(childNamespace, attributeType, results);
        }
    }

    /// <summary>
    /// Derives collection name by removing "Base" suffix.
    /// </summary>
    private static string DeriveName(string className)
    {
        return className.EndsWith("Base", StringComparison.Ordinal)
            ? className.Substring(0, className.Length - 4)
            : className;
    }

    /// <summary>
    /// Gets a base type by its simple name, searching efficiently through known namespaces.
    /// </summary>
    private static INamedTypeSymbol? GetBaseTypeFromName(string baseTypeName, Compilation compilation)
    {
        // Try common ServiceType namespaces first (most likely locations)
        var commonNamespaces = new[]
        {
            "FractalDataWorks.Services.Connections.Abstractions",
            "FractalDataWorks.Services.Authentication.Abstractions", 
            "FractalDataWorks.Services.DataGateway.Abstractions",
            "FractalDataWorks.Services.Scheduling.Abstractions",
            "FractalDataWorks.Services.SecretManagers.Abstractions",
            "FractalDataWorks.Services.Transformations.Abstractions",
            "FractalDataWorks.DataContainers.Abstractions"
        };

        foreach (var ns in commonNamespaces)
        {
            var fullName = $"{ns}.{baseTypeName}";
            var type = compilation.GetTypeByMetadataName(fullName);
            if (type != null) return type;
        }

        // Fallback: search more broadly but still avoid global scanning
        return SearchTypeInAssemblies(baseTypeName, compilation);
    }

    /// <summary>
    /// Searches for a type in referenced assemblies without doing expensive global traversal.
    /// </summary>
    private static INamedTypeSymbol? SearchTypeInAssemblies(string typeName, Compilation compilation)
    {
        // Check current compilation first
        var types = GetTypesFromNamespace(compilation.GlobalNamespace, typeName);
        if (types.Any()) return types.First();

        // Check only essential referenced assemblies (avoid scanning everything)
        foreach (var reference in compilation.References.Take(10)) // Limit to avoid performance issues
        {
            if (compilation.GetAssemblyOrModuleSymbol(reference) is IAssemblySymbol assemblySymbol)
            {
                types = GetTypesFromNamespace(assemblySymbol.GlobalNamespace, typeName);
                if (types.Any()) return types.First();
            }
        }

        return null;
    }

    /// <summary>
    /// Gets types with a specific name from a namespace hierarchy efficiently.
    /// </summary>
    private static IEnumerable<INamedTypeSymbol> GetTypesFromNamespace(INamespaceSymbol namespaceSymbol, string typeName)
    {
        // Check types in current namespace
        foreach (var type in namespaceSymbol.GetTypeMembers(typeName))
        {
            yield return type;
        }

        // Recursively check child namespaces (but limit depth to avoid performance issues)
        foreach (var childNamespace in namespaceSymbol.GetNamespaceMembers())
        {
            foreach (var type in GetTypesFromNamespace(childNamespace, typeName))
            {
                yield return type;
            }
        }
    }

    /// <summary>
    /// Discovers service types that inherit from a base type using targeted searches instead of global scanning.
    /// </summary>
    private static void DiscoverServiceTypesTargeted(INamedTypeSymbol baseType, Compilation compilation, HashSet<INamedTypeSymbol> results)
    {
        // Search in current compilation
        SearchInheritorsInNamespace(compilation.GlobalNamespace, baseType, results);

        // Search in referenced assemblies but limit scope to avoid performance issues
        foreach (var reference in compilation.References.Take(5)) // Limit assembly scanning
        {
            if (compilation.GetAssemblyOrModuleSymbol(reference) is IAssemblySymbol assemblySymbol)
            {
                SearchInheritorsInNamespace(assemblySymbol.GlobalNamespace, baseType, results);
            }
        }
    }

    /// <summary>
    /// Searches for types inheriting from a base type within a namespace hierarchy.
    /// </summary>
    private static void SearchInheritorsInNamespace(INamespaceSymbol namespaceSymbol, INamedTypeSymbol baseType, HashSet<INamedTypeSymbol> results)
    {
        // Check types in current namespace
        foreach (var type in namespaceSymbol.GetTypeMembers())
        {
            if (InheritsFromType(type, baseType))
            {
                results.Add(type);
            }
        }

        // Recursively check child namespaces
        foreach (var childNamespace in namespaceSymbol.GetNamespaceMembers())
        {
            SearchInheritorsInNamespace(childNamespace, baseType, results);
        }
    }

    /// <summary>
    /// Checks if a type inherits from a specified base type.
    /// </summary>
    private static bool InheritsFromType(INamedTypeSymbol type, INamedTypeSymbol baseType)
    {
        var current = type.BaseType;
        while (current != null)
        {
            if (SymbolEqualityComparer.Default.Equals(current.OriginalDefinition, baseType.OriginalDefinition))
                return true;
            current = current.BaseType;
        }
        return false;
    }


    /// <summary>
    /// Extracts the base type name from the ServiceTypeCollectionAttribute.
    /// </summary>
    private static string? ExtractBaseTypeNameFromAttribute(AttributeData attribute)
    {
        // ServiceTypeCollectionAttribute now uses Type parameters, extract from BaseType property
        if (attribute.ConstructorArguments.Length > 0 && attribute.ConstructorArguments[0].Value is INamedTypeSymbol baseTypeSymbol)
        {
            return baseTypeSymbol.ToDisplayString();
        }
        return null;
    }

    /// <summary>
    /// Builds a ServiceType collection definition from an attributed collection class.
    /// </summary>
    private static EnumTypeInfoModel? BuildServiceTypeCollectionDefinitionFromAttributedCollection(
        INamedTypeSymbol collectionClass,
        INamedTypeSymbol baseType,
        List<INamedTypeSymbol> serviceTypes,
        Compilation compilation,
        AttributeData attribute)
    {
        // Extract collection name from Type parameter (collectionType.Name)
        var collectionName = attribute.ConstructorArguments.Length > 2 && attribute.ConstructorArguments[2].Value is INamedTypeSymbol collectionTypeSymbol
            ? collectionTypeSymbol.Name
            : DeriveName(collectionClass.Name);

        // Extract default return type from Type parameter (defaultReturnType.FullName)
        var defaultReturnType = attribute.ConstructorArguments.Length > 1 && attribute.ConstructorArguments[1].Value is INamedTypeSymbol returnTypeSymbol
            ? returnTypeSymbol.ToDisplayString()
            : baseType.ToDisplayString();

        var containingNamespace = collectionClass.ContainingNamespace?.ToDisplayString() ?? string.Empty;

        return new EnumTypeInfoModel
        {
            Namespace = containingNamespace,
            ClassName = baseType.Name,
            FullTypeName = baseType.ToDisplayString(),
            CollectionName = collectionName ?? DeriveName(collectionClass.Name),
            CollectionBaseType = baseType.ToDisplayString(),
            ReturnType = defaultReturnType ?? baseType.ToDisplayString(),
            InheritsFromCollectionBase = true,
            UseSingletonInstances = true,
            GenerateFactoryMethods = true,
            LookupProperties = ExtractServiceTypeLookupProperties(baseType, compilation)
        };
    }

    /// <summary>
    /// STEP 5: Definition Construction
    /// Builds collection definition for ServiceType collections.
    /// </summary>
    private static EnumTypeInfoModel? BuildServiceTypeCollectionDefinition(
        INamedTypeSymbol collectionClass, 
        INamedTypeSymbol baseType, 
        List<INamedTypeSymbol> serviceTypes, 
        Compilation compilation)
    {
        var collectionName = collectionClass.Name;
        var baseTypeName = baseType.Name;
        
        // Detect return type based on inheritance (like TypeCollectionGenerator)
        var returnType = DetectReturnType(collectionClass.BaseType, compilation);

        // Use collection class namespace
        var containingNamespace = collectionClass.ContainingNamespace?.ToDisplayString() ?? string.Empty;
            
        return new EnumTypeInfoModel
        {
            Namespace = containingNamespace,
            ClassName = baseTypeName,
            FullTypeName = baseType.ToDisplayString(),
            CollectionName = collectionName,
            CollectionBaseType = baseType.ToDisplayString(),
            ReturnType = returnType,
            InheritsFromCollectionBase = true,
            UseSingletonInstances = true,
            GenerateFactoryMethods = true,
            LookupProperties = ExtractServiceTypeLookupProperties(baseType, compilation)
        };
    }

    /// <summary>
    /// STEP 5.2: Return type detection
    /// Determines return type based on generic arity (TBase vs TGeneric).
    /// </summary>
    private static string DetectReturnType(ITypeSymbol? baseType, Compilation compilation)
    {
        if (baseType is INamedTypeSymbol { IsGenericType: true } namedBase)
        {
            var constructedFrom = namedBase.ConstructedFrom.ToDisplayString();
            
            if (constructedFrom.Contains("ServiceTypeCollectionBase"))
            {
                // ServiceTypeCollectionBase<TBase,TGeneric,TService,TConfiguration,TFactory>
                if (namedBase.TypeArguments.Length >= 2)
                {
                    // Return TGeneric (second type parameter)
                    return namedBase.TypeArguments[1].ToDisplayString();
                }
                // Single generic: ServiceTypeCollectionBase<TBase> -> return TBase
                else if (namedBase.TypeArguments.Length == 1)
                {
                    return namedBase.TypeArguments[0].ToDisplayString();
                }
            }
        }

        return "object"; // Fallback
    }

    /// <summary>
    /// Extract lookup properties from ServiceTypeBase for automatic method generation.
    /// </summary>
    private static EquatableArray<PropertyLookupInfoModel> ExtractServiceTypeLookupProperties(INamedTypeSymbol baseType, Compilation compilation)
    {
        var lookupProperties = new List<PropertyLookupInfoModel>();
        
        var typeLookupAttributeType = compilation.GetTypeByMetadataName("FractalDataWorks.ServiceTypes.Attributes.TypeLookupAttribute");
        
        var currentType = baseType;
        while (currentType != null)
        {
            foreach (var property in currentType.GetMembers().OfType<IPropertySymbol>())
            {
                var typeLookupAttr = property.GetAttributes()
                    .FirstOrDefault(ad => typeLookupAttributeType != null && SymbolEqualityComparer.Default.Equals(ad.AttributeClass, typeLookupAttributeType));

                if (typeLookupAttr != null && typeLookupAttr.ConstructorArguments.Length > 0)
                {
                    var methodName = typeLookupAttr.ConstructorArguments[0].Value?.ToString();
                    if (!string.IsNullOrEmpty(methodName))
                    {
                        lookupProperties.Add(new PropertyLookupInfoModel
                        {
                            PropertyName = property.Name,
                            PropertyType = property.Type.ToDisplayString(),
                            LookupMethodName = methodName!,
                            AllowMultiple = false,
                            ReturnType = baseType.ToDisplayString()
                        });
                    }
                }
            }
            
            currentType = currentType.BaseType;
        }
        
        return new EquatableArray<PropertyLookupInfoModel>(lookupProperties);
    }


    /// <summary>
    /// PHASE 7: Code Generation and Output
    /// Executes the final code generation for discovered ServiceType collections.
    /// </summary>
    private static void Execute(
        SourceProductionContext context,
        EnumTypeInfoModel def,
        Compilation compilation,
        ImmutableArray<INamedTypeSymbol> discoveredServiceTypes,
        INamedTypeSymbol collectionClass)
    {
        if (def == null) throw new ArgumentNullException(nameof(def));
        if (compilation == null) throw new ArgumentNullException(nameof(compilation));

        // STEP 7.1: Base Type Resolution
        var baseTypeSymbol = compilation.GetTypeByMetadataName(def.CollectionBaseType ?? def.FullTypeName);
        if (baseTypeSymbol == null) return;

        // STEP 7.2: Return Type Detection
        if (string.IsNullOrEmpty(def.ReturnType))
        {
            def.ReturnType = "FractalDataWorks.ServiceTypes.ServiceTypeBase";
        }

        // STEP 7.3: Service Type Model Conversion
        var values = new List<EnumValueInfoModel>();
        foreach (var serviceType in discoveredServiceTypes)
        {
            var name = serviceType.Name;

            // Extract base constructor ID if available
            var baseConstructorId = ExtractBaseConstructorId(serviceType, compilation);

            var serviceTypeValueInfo = new EnumValueInfoModel
            {
                ShortTypeName = serviceType.Name,
                FullTypeName = serviceType.ToDisplayString(),
                Name = name,
                ReturnTypeNamespace = serviceType.ContainingNamespace?.ToDisplayString() ?? string.Empty,
                Constructors = ExtractConstructorInfo(serviceType),
                BaseConstructorId = baseConstructorId
            };
            values.Add(serviceTypeValueInfo);
        }

        // STEP 7.4: Final Code Generation
        GenerateServiceTypeCollection(context, def, new EquatableArray<EnumValueInfoModel>(values), compilation, collectionClass);
    }

    /// <summary>
    /// Constructor information extraction for Create method overloads.
    /// </summary>
    private static List<ConstructorInfo> ExtractConstructorInfo(INamedTypeSymbol serviceType)
    {
        var constructors = new List<ConstructorInfo>();

        foreach (var constructor in serviceType.Constructors.Where(c => c.DeclaredAccessibility == Accessibility.Public))
        {
            var parameters = new List<ParameterInfo>();

            foreach (var param in constructor.Parameters)
            {
                parameters.Add(new ParameterInfo
                {
                    Name = param.Name,
                    TypeName = param.Type.ToDisplayString(),
                    DefaultValue = param.HasExplicitDefaultValue ?
                        GetDefaultValueString(param.ExplicitDefaultValue, param.Type) : null
                });
            }

            constructors.Add(new ConstructorInfo { Parameters = parameters });
        }

        return constructors;
    }

    /// <summary>
    /// Helper method to convert default values to string representation.
    /// </summary>
    private static string GetDefaultValueString(object? defaultValue, ITypeSymbol parameterType)
    {
        if (defaultValue == null)
        {
            return parameterType.IsReferenceType || parameterType.NullableAnnotation == NullableAnnotation.Annotated
                ? "null" : "default";
        }

        return defaultValue switch
        {
            string str => $"\"{str}\"",
            char ch => $"'{ch}'",
            bool b => b ? "true" : "false",
            float f => $"{f}f",
            double d => $"{d}d",
            decimal dec => $"{dec}m",
            long l => $"{l}L",
            uint ui => $"{ui}u",
            ulong ul => $"{ul}ul",
            _ => defaultValue.ToString() ?? "default"
        };
    }

    /// <summary>
    /// Determines the effective return type for the collection based on inheritance.
    /// For ServiceTypeCollectionBase&lt;TBase,TGeneric,...&gt; returns TGeneric, for ServiceTypeCollectionBase&lt;TBase&gt; returns TBase.
    /// </summary>
    private static string? DetermineReturnType(INamedTypeSymbol collectionClass)
    {
        var currentType = collectionClass.BaseType;
        
        while (currentType != null)
        {
            if (currentType.IsGenericType)
            {
                var genericDefinition = currentType.ConstructedFrom;
                
                // Check for ServiceTypeCollectionBase<TBase,TGeneric,...> (multiple generics)
                if (string.Equals(genericDefinition.Name, "ServiceTypeCollectionBase", StringComparison.Ordinal) && currentType.TypeArguments.Length >= 2)
                {
                    // Return TGeneric (second type parameter)
                    return currentType.TypeArguments[1].Name;
                }
                
                // Check for ServiceTypeCollectionBase<TBase> (single generic)
                if (string.Equals(genericDefinition.Name, "ServiceTypeCollectionBase", StringComparison.Ordinal) && currentType.TypeArguments.Length == 1)
                {
                    // Return TBase (first type parameter)
                    return currentType.TypeArguments[0].Name;
                }
            }
            
            currentType = currentType.BaseType;
        }
        
        return null;
    }

    /// <summary>
    /// Extracts the ID value from a base constructor invocation if it exists.
    /// This method parses the syntax tree to find base constructor calls like:
    /// public sealed class OpenState() : ConnectionStateBase(3, "Open")
    /// and extracts the first integer argument (3 in this example).
    /// </summary>
    private static int? ExtractBaseConstructorId(INamedTypeSymbol typeSymbol, Compilation compilation)
    {
        // Get all syntax references for this type
        var syntaxRefs = typeSymbol.DeclaringSyntaxReferences;

        foreach (var syntaxRef in syntaxRefs)
        {
            // Get the syntax node
            var syntaxNode = syntaxRef.GetSyntax();

            // Look for ClassDeclarationSyntax
            if (syntaxNode is ClassDeclarationSyntax classDeclaration)
            {
                // Check for primary constructor syntax
                if (classDeclaration.ParameterList != null && classDeclaration.BaseList != null)
                {
                    // Look for the base class with arguments
                    foreach (var baseType in classDeclaration.BaseList.Types)
                    {
                        if (baseType.Type is SimpleNameSyntax || baseType.Type is IdentifierNameSyntax)
                        {
                            // Primary constructor pattern with base arguments
                            // Find the PrimaryConstructorBaseTypeSyntax
                            if (baseType is PrimaryConstructorBaseTypeSyntax primaryBase &&
                                primaryBase.ArgumentList != null &&
                                primaryBase.ArgumentList.Arguments.Count > 0)
                            {
                                // Get the first argument
                                var firstArg = primaryBase.ArgumentList.Arguments[0];

                                // Check if it's a literal integer
                                if (firstArg.Expression is LiteralExpressionSyntax literal &&
                                    literal.Token.Value is int idValue)
                                {
                                    return idValue;
                                }
                            }
                        }
                    }
                }

                // Check for traditional constructor with base call
                var constructors = classDeclaration.Members.OfType<ConstructorDeclarationSyntax>();

                foreach (var constructor in constructors)
                {
                    // Look for base constructor initializer
                    if (constructor.Initializer != null &&
                        constructor.Initializer.Kind() == SyntaxKind.BaseConstructorInitializer &&
                        constructor.Initializer.ArgumentList.Arguments.Count > 0)
                    {
                        // Get the first argument
                        var firstArg = constructor.Initializer.ArgumentList.Arguments[0];

                        // Check if it's a literal integer
                        if (firstArg.Expression is LiteralExpressionSyntax literal &&
                            literal.Token.Value is int idValue)
                        {
                            return idValue;
                        }
                    }
                }
            }
        }

        return null;
    }

    /// <summary>
    /// Generates the ServiceType collection class using the existing builder infrastructure.
    /// </summary>
    private static void GenerateServiceTypeCollection(
        SourceProductionContext context,
        EnumTypeInfoModel def,
        EquatableArray<EnumValueInfoModel> values,
        Compilation compilation,
        INamedTypeSymbol collectionClass)
    {
        try
        {
            // Determine the effective return type based on collection inheritance (like TypeCollectionGenerator)
            var effectiveReturnType = DetermineReturnType(collectionClass);
            if (effectiveReturnType == null)
            {
                // Fallback to base type name
                effectiveReturnType = def.ClassName;
            }

            // Determine if the user's declared class is static or abstract
            var isUserClassStatic = collectionClass.IsStatic;
            var isUserClassAbstract = collectionClass.IsAbstract;

            // Use the shared GenericCollectionBuilder with configuration for ServiceTypeCollections
            var config = CollectionBuilderConfiguration.ForServiceTypeCollections();
            var builder = new GenericCollectionBuilder(config);

            // Generate the collection with all enhanced features
            var generatedCode = builder
                .WithDefinition(def)
                .WithValues(values.Cast<GenericValueInfoModel>().ToList())
                .WithReturnType(effectiveReturnType)
                .WithCompilation(compilation)
                .WithUserClassModifiers(isUserClassStatic, isUserClassAbstract)
                .Build();

            var fileName = $"{def.CollectionName}.g.cs";
            context.AddSource(fileName, generatedCode);
        }
        catch (Exception ex)
        {
            // Generate diagnostic for any errors during generation
            var diagnostic = Diagnostic.Create(
                new DiagnosticDescriptor(
                    "STCG001",
                    "ServiceType Collection Generation Failed",
                    "Failed to generate ServiceType collection {0}: {1}",
                    "ServiceTypeCollectionGenerator",
                    DiagnosticSeverity.Error,
                    isEnabledByDefault: true),
                Location.None,
                def.CollectionName,
                ex.Message);

            context.ReportDiagnostic(diagnostic);
        }
    }
}