using System;
using System.Collections.Generic;
using System.Linq;
using FractalDataWorks.CodeBuilder.Abstractions;
using FractalDataWorks.CodeBuilder.CSharp.Builders;
using FractalDataWorks.SourceGenerators.Configuration;
using FractalDataWorks.SourceGenerators.Models;

namespace FractalDataWorks.SourceGenerators.Generators;

/// <summary>
/// Generates Empty classes for collection value types.
/// Responsible for creating EmptyXXX classes that represent empty/default instances.
/// </summary>
public sealed class EmptyClassGenerator
{
    private readonly CollectionBuilderConfiguration _config;

    /// <summary>
    /// Initializes a new instance of the <see cref="EmptyClassGenerator"/> class.
    /// </summary>
    /// <param name="config">The collection builder configuration.</param>
    public EmptyClassGenerator(CollectionBuilderConfiguration config)
    {
        _config = config ?? throw new ArgumentNullException(nameof(config));
    }

    /// <summary>
    /// Generates an Empty class for the specified value type.
    /// </summary>
    /// <param name="valueType">The value type information.</param>
    /// <param name="collectionNamespace">The namespace for the collection.</param>
    /// <param name="baseClassType">The base class type (optional).</param>
    /// <param name="baseClassNamespace">The base class namespace (optional).</param>
    /// <returns>The generated Empty class code.</returns>
    public string Generate(
        GenericValueInfoModel valueType,
        string collectionNamespace,
        string? baseClassType = null,
        string? baseClassNamespace = null)
    {
        if (valueType == null)
            throw new ArgumentNullException(nameof(valueType));

        if (string.IsNullOrWhiteSpace(collectionNamespace))
            throw new ArgumentException("Collection namespace cannot be null or empty.", nameof(collectionNamespace));

        if (!_config.GenerateEmptyClasses)
            return string.Empty;

        var emptyClassName = $"Empty{valueType.Name}";
        var classBuilder = new ClassBuilder()
            .WithNamespace(collectionNamespace)
            .WithName(emptyClassName)
            .WithAccessModifier("internal")
            .AsSealed()
            .WithXmlDoc($"Represents an empty instance of {valueType.Name}.");

        // Add usings
        var usings = new HashSet<string>(StringComparer.Ordinal)
        {
            "System"
        };

        if (!string.IsNullOrEmpty(baseClassNamespace) && baseClassNamespace != collectionNamespace)
        {
            usings.Add(baseClassNamespace);
        }

        classBuilder.WithUsings(usings.ToArray());

        // Set base class if provided
        if (!string.IsNullOrEmpty(baseClassType))
        {
            var baseClassName = baseClassType;
            if (baseClassType.Contains('.'))
            {
                baseClassName = baseClassType.Substring(baseClassType.LastIndexOf('.') + 1);
            }
            classBuilder.WithBaseClass(baseClassName);
        }

        // Add constructor that initializes with default values
        var constructor = new ConstructorBuilder()
            .WithClassName(emptyClassName)
            .WithAccessModifier("internal")
            .WithXmlDoc("Initializes a new instance of the empty class with default values.");

        // If there's a base class with constructor parameters, call base with defaults
        if (valueType.Constructor?.Parameters != null && valueType.Constructor.Parameters.Count > 0)
        {
            var baseCallArgs = valueType.Constructor.Parameters
                .Select(p => GetDefaultValueForParameter(p))
                .ToArray();

            constructor.WithBaseCall(baseCallArgs);
        }
        else if (!string.IsNullOrEmpty(baseClassType))
        {
            // Simple base class call with no parameters
            constructor.WithBaseCall();
        }

        classBuilder.WithConstructor(constructor);

        return classBuilder.Build();
    }

    /// <summary>
    /// Gets the default value for a constructor parameter based on its type.
    /// </summary>
    private static string GetDefaultValueForParameter(ParameterInfo parameter)
    {
        if (parameter == null)
            return "default";

        // Use the parameter's default value if specified
        if (!string.IsNullOrEmpty(parameter.DefaultValue))
            return parameter.DefaultValue;

        // Return type-appropriate defaults
        return parameter.Type switch
        {
            "string" => "string.Empty",
            "int" => "0",
            "long" => "0L",
            "double" => "0.0",
            "float" => "0.0f",
            "decimal" => "0m",
            "bool" => "false",
            "Guid" => "Guid.Empty",
            "DateTime" => "DateTime.MinValue",
            _ when parameter.Type.EndsWith("?") => "null",
            _ => "default"
        };
    }
}
