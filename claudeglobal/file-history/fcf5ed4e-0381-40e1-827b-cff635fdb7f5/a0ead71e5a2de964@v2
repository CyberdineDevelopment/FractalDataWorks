# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

FractalDataWorks Developer Kit is a comprehensive .NET framework providing enterprise-grade abstractions for services, configurations, messaging, collections, and code generation through source generators. The framework emphasizes type safety, compile-time code generation, and service-oriented architecture patterns.

## Build Commands

### Basic Build & Test
```powershell
# Restore packages
dotnet restore

# Build the solution (default: Debug configuration)
dotnet build

# Build with specific configuration
dotnet build --configuration Release
dotnet build --configuration Alpha
dotnet build --configuration Beta
dotnet build --configuration Preview

# Run unit tests (excluding integration tests)
dotnet test --filter "Category!=Integration"

# Run tests with coverage
dotnet test --collect:"XPlat Code Coverage" --settings coverlet.runsettings
```

### Configuration Levels
- **Debug**: Fast development, no analyzers, warnings allowed
- **Experimental**: Minimal enforcement, basic analyzers enabled
- **Alpha**: Basic checks, optimizations enabled
- **Beta**: Recommended checks, warnings as errors
- **Preview**: Strict checks for pre-release
- **Release**: Production-ready with full analysis

### Package Management
```powershell
# Add packages using dotnet CLI (preferred method)
dotnet add package PackageName

# Pack NuGet packages
dotnet pack --configuration Release --output ./packages

# Security audit
dotnet list package --vulnerable --include-transitive
```

## Architecture

### Core Framework Layers

1. **Abstractions Layer** (`*.Abstractions` projects)
   - Target: `netstandard2.0` (maximum compatibility)
   - Contains: Interfaces, command definitions, configuration contracts
   - No implementation dependencies
   - ImplicitUsings disabled (explicit using statements required)

2. **Implementation Layer** (concrete projects)
   - Target: `netstandard2.0;net10.0` (multi-targeting)
   - Contains: Base classes, service implementations, factories
   - ImplicitUsings disabled (explicit using statements required)

3. **Source Generators** (`*.SourceGenerators` projects)
   - Target: `netstandard2.0` (compiler requirement)
   - Generates code at compile-time for collections, service types, messages
   - ImplicitUsings disabled (explicit using statements required)

### Key Framework Components

#### Service Architecture
- **Services**: Can have domain-specific methods AND must implement `Execute(TCommand)` and `Execute<T>(TCommand)` that can run any domain method
- **Domain Method Uniformity**: All services in a domain must have identical public method signatures
- **Commands**: Command interfaces define contracts, concrete classes implement them with `{ get; init; }` properties
- **ServiceTypes**: Runtime discovery and registration of service implementations via source generation
- **Providers**: Abstract "get any implementation" pattern for service resolution
- **Translators**: Convert domain commands to technology-specific operations (SQL, REST, etc.)

#### Type Collections & ServiceType Collections
- **TypeCollectionBase**: Base for source-generated type collections
- **ServiceTypeCollectionBase**: Specialized collections for service type discovery
- **NOT EnhancedEnum patterns** - they enhance type discovery but are distinct from EnhancedEnums
- Source generators scan solution for types and generate lookup methods

#### Configuration System
- All configuration interfaces extend `IGenericConfiguration`
- Configuration binding uses strongly-typed classes
- appsettings.json structure: `Services:{Domain}:{ImplementationName}`

#### Results & Messages
- **Result Pattern**: `GenericResult` and `GenericResult<T>` return success/failure state with collection of messages
- Results can contain typed value on success
- Factory methods: `Success()` / `Failure()` accept string or `IGenericMessage` objects
- **Never throw exceptions for anticipated conditions** - return failed Result with Message
- **Messages**: Structured objects extending `MessageTemplate<TSeverity>` with Id, Name, Severity, Message, Code, Source, Timestamp, Details
- Messages are added to Results, not just strings
- Use `[MessageCollection]` attribute on base message class for source generation

#### Logging
- **Source-generated logging** using `[LoggerMessage]` attribute on partial methods
- High-performance structured logging with compile-time code generation
- See `FractalDataWorks.Services/Logging/ServiceBaseLog.cs` for pattern examples
- Each log method has EventId, Level, and message template
- Logging classes are untestable - decorate with `[ExcludeFromCodeCoverage]` with justification

### Source Generator Projects

1. **FractalDataWorks.Collections.SourceGenerators**: TypeCollection generation
2. **FractalDataWorks.EnhancedEnums.SourceGenerators**: Enhanced enum generation (distinct from TypeCollections)
3. **FractalDataWorks.ServiceTypes.SourceGenerators**: ServiceType discovery and registration
4. **FractalDataWorks.Messages.SourceGenerators**: Message collection generation

These must be referenced as analyzers:
```xml
<ProjectReference Include="..\FractalDataWorks.*.SourceGenerators\*.csproj"
                  OutputItemType="Analyzer" ReferenceOutputAssembly="false" />
```

### Service Development Pattern

When creating a new service domain:

1. Create `{Domain}.Abstractions` project (netstandard2.0)
   - Command interfaces defining contracts (e.g., `ICreateUserCommand`)
   - Service interface with domain-specific methods AND `Execute` methods
   - Configuration interface (`IGenericConfiguration`)
   - Provider interface (`IGenericServiceProvider`)
   - Message base classes with `[MessageCollection]` attribute
   - Logging method signatures with `[LoggerMessage]` attributes

2. Create `{Domain}` project (net10.0)
   - ServiceType definitions with `[ServiceTypeCollection]`
   - Provider implementation
   - Service base classes
   - Message implementations
   - Logging implementations

3. Create implementation projects (e.g., `{Domain}.Database`)
   - Concrete command classes implementing command interfaces
   - Service implementation with ALL domain methods (identical signatures across implementations)
   - Command translators (domain commands → technology operations)
   - ServiceType registration class

### Modern C# Patterns

This codebase uses **preview language features** (LangVersion: preview):

- **Collection expressions**: `[]` instead of `new List<T>()`
- **Init-only properties**: `{ get; init; }` for immutable objects
- **No Async suffix**: Methods returning `Task` don't use "Async" suffix
- **File-scoped namespaces**: Single namespace per file
- **ImplicitUsings disabled**: All projects require explicit using statements
- **No double-null defensive programming**: Let the compiler handle null defense
- **One type per file**: Only one primary type per file (generic variants OK - `TypeBase<T>`, `TypeBase<T,T1>`, `TypeBase` all in `TypeBase.cs`)

### Multi-Targeting Notes

Most projects target both `netstandard2.0` and `net10.0`:
- netstandard2.0 requires `IsExternalInit` package for init properties
- netstandard2.0 requires `PolySharp` for modern C# features
- Test projects target `net10.0` only

## Project Organization

```
src/
├── FractalDataWorks.Abstractions/               # Core abstractions
├── FractalDataWorks.Services.Abstractions/      # Service framework interfaces
├── FractalDataWorks.Services/                   # Service framework implementation (see logging examples)
├── FractalDataWorks.ServiceTypes/               # ServiceType base classes
├── FractalDataWorks.ServiceTypes.SourceGenerators/  # ServiceType code generation
├── FractalDataWorks.Collections/                # TypeCollection framework
├── FractalDataWorks.Collections.SourceGenerators/   # Collection code generation
├── FractalDataWorks.EnhancedEnums/              # Enhanced enum pattern (distinct from collections)
├── FractalDataWorks.EnhancedEnums.SourceGenerators/ # Enum code generation
├── FractalDataWorks.Messages/                   # Messaging framework
├── FractalDataWorks.Messages.SourceGenerators/  # Message code generation
├── FractalDataWorks.Configuration.Abstractions/ # Configuration contracts
├── FractalDataWorks.Configuration/              # Configuration implementation
├── FractalDataWorks.Results/                    # Result pattern implementation
├── FractalDataWorks.Data/                       # Data access abstractions
├── FractalDataWorks.DataStores/                 # Data storage implementations
├── FractalDataWorks.Services.{Domain}.Abstractions/  # Domain abstractions
├── FractalDataWorks.Services.{Domain}/          # Domain implementations
└── FractalDataWorks.Services.{Domain}.{Tech}/   # Technology-specific implementations

tests/
├── FractalDataWorks.Services.Tests/             # Matches src/FractalDataWorks.Services
├── FractalDataWorks.Collections.Tests/          # Matches src/FractalDataWorks.Collections
└── {ProjectName}.Tests/                # One test project per src project
```

## Testing

### Test Structure
- Test projects located in `tests/` directory
- One test project per source project with `.Tests` suffix
- Test project naming: `{SourceProjectName}.Tests`
- Example: `src/FractalDataWorks.Services` → `tests/FractalDataWorks.Services.Tests`

### Testing Framework
- **xUnit v3** for test framework
- **Shouldly** for assertions
- **Moq** for mocking (use alternatives only when Moq cannot handle complexity)

### Code Coverage
- All untestable code decorated with `[ExcludeFromCodeCoverage]` attribute
- XML documentation must include coverage exclusion reason:
  ```csharp
  /// <summary>
  /// Method description
  /// </summary>
  /// <ExcludedFromCoverage>Reason for exclusion</ExcludedFromCoverage>
  [ExcludeFromCodeCoverage]
  public void UntestableMethod() { }
  ```

### Running Tests
```powershell
# Run all tests
dotnet test

# Run with coverage
dotnet test --collect:"XPlat Code Coverage" --settings coverlet.runsettings

# Exclude integration tests
dotnet test --filter "Category!=Integration"
```

## Important Conventions

### File Organization
- **One type per file** - Each file should contain exactly one primary type
- Generic variants of the same type are allowed in one file
  - Example: `ServiceTypeBase`, `ServiceTypeBase<T>`, `ServiceTypeBase<T,T1>` all in `ServiceTypeBase.cs`
- File name must match the primary type name

### Command Pattern
- Command **interfaces** define contracts (e.g., `ICreateUserCommand`)
- Concrete **command classes** implement interfaces with `{ get; init; }` properties
- Commands unify domains - same interface contracts across all implementations
- Command objects are passed to `Execute()` methods

### Service Pattern
- Services can have **domain-specific methods** with business logic
- All services in a domain **must have identical public method signatures**
- Services **must also implement** `Execute(TCommand)` and `Execute<T>(TCommand)`
- Execute methods must be able to invoke any domain method based on command type
- Services inherit from `ServiceBase<TCommand, TConfiguration, TService>`

### Error Handling
- **Avoid throwing exceptions** for anticipated conditions
- Return `IGenericResult` with appropriate `IGenericMessage` for expected error cases
- Only throw exceptions for truly exceptional circumstances
- Add message classes to the domain's message collection for anticipated conditions
- Use source-generated logging for error tracking

### Result & Message Pattern
- All operations return `IGenericResult` or `IGenericResult<T>`
- Create message classes extending `MessageTemplate<TSeverity>` for all result states
- Messages contain: Id, Name, Severity, Message, Code, Source, Timestamp, Details, Data
- Use `[MessageCollection]` attribute on base message class
- Source generator creates message factory methods
- Messages are structured objects, not just strings
- Add messages to Results: `GenericResult.Success(messageObject)` or `GenericResult.Failure(messageObject)`

### Logging Pattern
- Use source-generated logging with `[LoggerMessage]` attribute
- Create partial static classes with partial methods decorated with `[LoggerMessage]`
- Each method specifies EventId, Level, and Message template
- Supports structured logging with parameter interpolation
- Example:
  ```csharp
  [LoggerMessage(
      EventId = 1,
      Level = LogLevel.Information,
      Message = "Command {CommandType} executed successfully in {Duration}ms")]
  public static partial void CommandExecuted(ILogger logger, string commandType, double duration);
  ```
- Logging classes are untestable - use `[ExcludeFromCodeCoverage(Justification = "reason")]`

### ServiceType Pattern
- ServiceTypes are **singletons** with static `Instance` property
- **Use deterministic GUID generation from type name** instead of sequential IDs
  - Prevents collision issues across domains
  - Reproducible builds
  - Merge-friendly
  - Generate GUID from fully qualified type name using deterministic hash
- `Name` property must match configuration's type name exactly
- Override `Register(IServiceCollection)` for DI registration
- Source generator discovers all ServiceType implementations

### Source Generator Workflow
1. Define base class/interface with `[TypeCollection]` or `[ServiceTypeCollection]`
2. Create concrete implementations across solution
3. Source generator scans at compile-time
4. Generated code provides static lookup methods
5. Enable diagnostics: Set `<EmitCompilerGeneratedFiles>true</EmitCompilerGeneratedFiles>`

## CI/CD

GitHub Actions workflow (`.github/workflows/ci.yml`):
- Triggered on push to: master, main, develop, beta/*, release/*, experimental/*, feature/*
- Build configuration based on branch
- Uses Nerdbank.GitVersioning for versioning
- Runs CodeQL security scanning
- Publishes to GitHub Packages (internal) or NuGet.org (public)
- Create `nopublish` file in root to skip package publishing

## Version Management

Uses Nerdbank.GitVersioning:
- Version configured in `version.json`
- Automatic semantic versioning
- Build metadata from git commits
- Version variables available via `nbgv` command

## Central Package Management

Uses `Directory.Packages.props` for centralized package versions. Samples directory excluded from central management.

## Critical Rules

1. **Never remove source generator references** - builds will fail silently
2. **Match ServiceType names exactly** to configuration type names
3. **Use PowerShell 7 (pwsh)** for scripts, not Windows PowerShell
4. **Keep abstractions in netstandard2.0** for maximum compatibility
5. **Command interfaces define contracts, concrete classes implement them**
6. **All services in a domain have identical public method signatures** AND implement Execute methods
7. **ServiceTypes are singletons** with deterministic GUID IDs generated from type name
8. **Multi-target where appropriate**: netstandard2.0;net10.0
9. **Use dotnet add package** - never manually edit project files for packages
10. **No double-null defensive programming** - let compiler handle null checks
11. **TypeCollections and ServiceTypeCollections are NOT EnhancedEnum patterns**
12. **Avoid exceptions** - return Results with Messages for anticipated conditions
13. **Use source-generated logging** with `[LoggerMessage]` attribute pattern
14. **All untestable code** must have `[ExcludeFromCodeCoverage]` with justification
15. **Tests use xUnit v3, Shouldly, and Moq** - located in tests/ directory matching src/ structure
16. **One type per file** - generic variants of same type allowed together
17. **Messages are structured objects** extending `MessageTemplate<TSeverity>`, not just strings
18. **Results contain message collections** - can have multiple messages per result
19. **ImplicitUsings always disabled** - all using statements must be explicit
