using System;
using System.Collections.Generic;
using FractalDataWorks.ServiceTypes;
using FractalDataWorks.Services.Abstractions;
using FractalDataWorks.DataContainers.Abstractions;

namespace FractalDataWorks.Services.Transformations.Abstractions;

/// <summary>
/// Base class for transformation service type definitions that inherit from ServiceTypeBase.
/// Provides transformation-specific metadata and capabilities.
/// </summary>
/// <typeparam name="TService">The transformation service type.</typeparam>
/// <typeparam name="TFactory">The factory type for creating transformation service instances.</typeparam>
/// <typeparam name="TConfiguration">The transformation configuration type.</typeparam>
/// <remarks>
/// This class replaces the old EnhancedEnum-based TransformationServiceType.
/// Transformation types should inherit from this class and provide metadata only -
/// no instantiation logic should be included (that belongs in factories).
/// </remarks>
public abstract class TransformationTypeBase<TService, TFactory, TConfiguration> :
    ServiceTypeBase<TService, TFactory, TConfiguration>
    where TService : class, ITransformationProvider
    where TFactory : class, IServiceFactory<TService, TConfiguration>
    where TConfiguration : class, ITransformationsConfiguration
{
    /// <summary>
    /// Gets the input type for this transformation.
    /// </summary>
    /// <remarks>
    /// The .NET type that this transformation accepts as input.
    /// Examples: typeof(string), typeof(Stream), typeof(DataTable), etc.
    /// </remarks>
    public Type InputType { get; }

    /// <summary>
    /// Gets the output type for this transformation.
    /// </summary>
    /// <remarks>
    /// The .NET type that this transformation produces as output.
    /// Should be compatible with downstream transformation inputs
    /// to enable pipeline composition.
    /// </remarks>
    public Type OutputType { get; }

    /// <summary>
    /// Gets a value indicating whether this transformation supports streaming.
    /// </summary>
    /// <remarks>
    /// Streaming transformations can process data as it arrives,
    /// without loading the entire dataset into memory. This is
    /// essential for large data processing scenarios.
    /// </remarks>
    public bool SupportsStreaming { get; }

    /// <summary>
    /// Gets the data container types supported by this transformation.
    /// </summary>
    /// <remarks>
    /// Defines which data container formats this transformation can work with.
    /// This enables the data access layer to select appropriate transformations
    /// based on the source data format (CSV, JSON, Parquet, etc.).
    /// </remarks>
    public IDataContainerType[] SupportedContainers { get; }

    /// <summary>
    /// Gets the supported input data types for this transformation.
    /// </summary>
    /// <remarks>
    /// String identifiers for the types of data this transformation can process.
    /// Examples: ["text/plain", "application/json", "application/csv", "binary"].
    /// Used for automatic transformation selection based on data type.
    /// </remarks>
    public virtual IReadOnlyList<string> SupportedInputTypes => new List<string>().AsReadOnly();

    /// <summary>
    /// Gets the supported output data types for this transformation.
    /// </summary>
    /// <remarks>
    /// String identifiers for the types of data this transformation produces.
    /// Should align with SupportedInputTypes of potential downstream transformations.
    /// </remarks>
    public virtual IReadOnlyList<string> SupportedOutputTypes => new List<string>().AsReadOnly();

    /// <summary>
    /// Gets the transformation categories this transformation belongs to.
    /// </summary>
    /// <remarks>
    /// Categorizes transformations for organization and discovery.
    /// Examples: ["data-cleaning", "format-conversion", "aggregation", "filtering"].
    /// </remarks>
    public virtual IReadOnlyList<string> SupportedCategories => new List<string>().AsReadOnly();

    /// <summary>
    /// Gets a value indicating whether this transformation supports parallel execution.
    /// </summary>
    /// <remarks>
    /// Parallel execution allows processing multiple data chunks simultaneously,
    /// improving performance for large datasets. Requires thread-safe implementation.
    /// </remarks>
    public virtual bool SupportsParallelExecution => true;

    /// <summary>
    /// Gets a value indicating whether this transformation supports result caching.
    /// </summary>
    /// <remarks>
    /// Caching can improve performance for expensive transformations
    /// when the same input data is processed multiple times.
    /// Consider memory usage and cache invalidation strategies.
    /// </remarks>
    public virtual bool SupportsTransformationCaching => false;

    /// <summary>
    /// Gets a value indicating whether this transformation supports pipeline mode.
    /// </summary>
    /// <remarks>
    /// Pipeline mode allows chaining multiple transformations together,
    /// where the output of one becomes the input of the next.
    /// Essential for complex data processing workflows.
    /// </remarks>
    public virtual bool SupportsPipelineMode => true;

    /// <summary>
    /// Gets a value indicating whether this transformation supports batch processing.
    /// </summary>
    /// <remarks>
    /// Batch processing handles multiple records together, often more
    /// efficiently than processing records individually.
    /// </remarks>
    public virtual bool SupportsBatchProcessing => false;

    /// <summary>
    /// Gets the maximum input size in bytes this transformation can handle.
    /// </summary>
    /// <remarks>
    /// Helps prevent out-of-memory errors and allows the system
    /// to select appropriate transformations based on data size.
    /// -1 indicates no limit.
    /// </remarks>
    public virtual long MaxInputSizeBytes => 104857600L; // 100MB default

    /// <summary>
    /// Gets the priority for transformation selection when multiple options are available.
    /// </summary>
    /// <remarks>
    /// Higher values indicate higher priority. Used when multiple transformations
    /// can handle the same input/output types to determine the preferred one.
    /// </remarks>
    public virtual int Priority => 50;

    /// <summary>
    /// Gets the estimated resource usage category for this transformation.
    /// </summary>
    /// <remarks>
    /// Helps with resource planning and scheduling. Categories might include:
    /// "low", "medium", "high", "memory-intensive", "cpu-intensive".
    /// </remarks>
    public virtual string ResourceUsageCategory => "medium";

    /// <summary>
    /// Initializes a new instance of the <see cref="TransformationTypeBase{TService, TConfiguration, TFactory}"/> class.
    /// </summary>
    /// <param name="id">The unique identifier for the transformation type.</param>
    /// <param name="name">The name of the transformation type.</param>
    /// <param name="inputType">The .NET type that this transformation accepts as input.</param>
    /// <param name="outputType">The .NET type that this transformation produces as output.</param>
    /// <param name="supportsStreaming">Indicates whether this transformation supports streaming.</param>
    /// <param name="supportedContainers">The data container types supported by this transformation.</param>
    /// <param name="category">The category for this transformation type (defaults to "Transformation").</param>
    protected TransformationTypeBase(
        int id,
        string name,
        Type inputType,
        Type outputType,
        bool supportsStreaming,
        IDataContainerType[] supportedContainers,
        string? category = null)
        : base(id, name, $"Services:Transformations:{name}", $"{name} Transformation Service", $"Transformation service for {inputType.Name} to {outputType.Name}", category ?? "Transformation")
    {
        InputType = inputType ?? throw new ArgumentNullException(nameof(inputType));
        OutputType = outputType ?? throw new ArgumentNullException(nameof(outputType));
        SupportsStreaming = supportsStreaming;
        SupportedContainers = supportedContainers ?? throw new ArgumentNullException(nameof(supportedContainers));
    }
}

