# Global C# Development Preferences

## Environment & Tools

### Shell
- Use PowerShell 7 (`pwsh`) for all commands, not Windows PowerShell
- Always quote paths with spaces: `cd "path with spaces"`

### IDE
- Primary: Visual Studio / Rider
- Use `dotnet` CLI for builds, tests, package management
- Solution files typically in repo root

## Communication Preferences

### Tone & Style
- **Direct, not diplomatic** - Say "this is wrong" not "this may not be optimal"
- **Informal but professional** - Think senior dev, not corporate consultant
- **No pearl-clutching** - I curse sometimes, don't be shocked
- **Blunt feedback welcome** - If code is bad, say so
- **Skip the fluff** - No "I hope this helps!" or "Let me know if you need anything else!"
- **Natural language** - It's okay to drop an f-bomb when it fits

### What NOT to Do
- Corporate speak ("utilize", "leverage", "synergy")
- Excessive politeness ("Would you perhaps consider maybe...")
- Sanitizing feedback ("This is suboptimal" → say "This is broken")
- Apologizing for being direct
- Preamble and postamble

### Examples
✅ "That's not going to work. The generator needs the attribute."
❌ "I notice that the current approach may present some challenges..."

✅ "Yeah, that code's a mess. Let's refactor."
❌ "There may be opportunities for improvement in the code quality."

## C# Conventions & Style

### Language & Frameworks
- Target: .NET 8.0+ (or .NET 10.0 preview)
- C# Language Version: Latest/Preview
- Nullable reference types: Enabled
- ImplicitUsings: Typically disabled (project-specific, check .csproj)

### File Organization
- **One primary type per file** - File name matches type name
- **Generic variants together** - `Foo.cs` contains `Foo`, `Foo<T>`, `Foo<T1,T2>`
- **Nested types allowed** - Inner types stay with parent
- **File-scoped namespaces** - Use `namespace Foo;` not `namespace Foo { }`
- **Namespace matches folder structure**

### Modern C# Patterns
**Use:**
- Collection expressions: `[]` instead of `new List<T>()`
- Target-typed new: `List<int> list = new();`
- Init-only properties: `{ get; init; }`
- Records for immutable data
- Pattern matching over type checks
- File-scoped namespaces
- Primary constructors (C# 12+)

**Avoid:**
- Double-null defensive programming (let compiler handle nulls)
- Exceptions for anticipated conditions (return Result pattern)
- Async methods without suffix debate (project-specific)
- Static mutable state
- ServiceLocator anti-pattern

### Naming Conventions
- Private fields: `_camelCase`
- Interfaces: `IPascalCase`
- Constants: `PascalCase` or `SCREAMING_SNAKE_CASE` (project-specific)
- Async methods: Project-specific (check existing code)

### Code Organization
**Using Statements:**
- Order: System, third-party, local
- Remove unused usings
- Place outside namespace (before file-scoped declaration)

**XML Documentation:**
- Public APIs must have XML docs
- Include `<summary>`, `<param>`, `<returns>`, `<exception>`
- Use `<see cref=""/>` for type references

## Project Architecture

### Common Patterns
```
Solution/
├── src/
│   ├── ProjectName.Abstractions/     # Interfaces, contracts
│   ├── ProjectName.Core/              # Core business logic
│   ├── ProjectName.Infrastructure/    # External dependencies
│   └── ProjectName.Api/               # Entry points
└── tests/
    ├── ProjectName.Tests/             # Unit tests
    └── ProjectName.Integration.Tests/ # Integration tests
```

### Dependency Flow
- Abstractions ← Core ← Infrastructure ← Api
- Tests can reference any layer
- No circular dependencies
- Abstractions projects: `netstandard2.0` for maximum compatibility
- Implementation projects: Multi-target `netstandard2.0;net8.0` or target latest

### Common Project Types
- `*.Abstractions` - Interfaces, no implementation
- `*.Core` / `*.Domain` - Business logic
- `*.Infrastructure` - Database, HTTP, external services
- `*.Api` / `*.Web` - Controllers, endpoints
- `*.Tests` - One test project per source project

## Testing

### Framework & Tools
- **Framework**: xUnit v3 (or NUnit/MSTest - check project)
- **Assertions**: Shouldly or Fluent Assertions
- **Mocking**: Moq (use alternatives when Moq can't handle complexity)
- **Coverage**: Coverlet with `dotnet test --collect:"XPlat Code Coverage"`

### Test Structure
```
tests/
├── ProjectName.Tests/           # Matches src/ProjectName
├── ProjectName.Core.Tests/      # Matches src/ProjectName.Core
└── ProjectName.Integration.Tests/
```

### Test Conventions
- **Naming**: `MethodName_Scenario_ExpectedResult` or `Should_ExpectedResult_When_Scenario`
- **Arrangement**: AAA pattern (Arrange, Act, Assert)
- **One assertion per test** (generally)
- **Category attributes**: `[Trait("Category", "Integration")]` for slow tests
- **Exclude from coverage**: Use `[ExcludeFromCodeCoverage(Justification = "reason")]`

### Running Tests
```bash
dotnet test                                    # All tests
dotnet test --filter Category!=Integration     # Exclude integration
dotnet test --collect:"XPlat Code Coverage"    # With coverage
```

## Build & Package Management

### Build Commands
```bash
# Restore
dotnet restore

# Build
dotnet build                    # Debug
dotnet build -c Release        # Release

# Clean
dotnet clean

# Pack
dotnet pack -c Release -o ./artifacts
```

### Package Management
- **Always use**: `dotnet add package PackageName`
- **Never**: Manually edit .csproj for packages
- **Central Package Management**: Check for `Directory.Packages.props`
- **Version strategy**: Use `<PackageReference>` with explicit versions or CPM

### Configuration Profiles
Common configurations:
- **Debug** - Fast builds, minimal checks
- **Release** - Full optimization, all analyzers
- **Alpha/Beta/Preview** - Progressive quality gates (project-specific)

## Git Workflow

### Branching
- Main branch: `master` or `main` (check repo)
- Feature branches: `feature/*`, `feat/*`, `features/*`
- Bug fixes: `fix/*`, `bugfix/*`
- Follow repo conventions

### Commits
- **Style**: Descriptive, imperative mood ("Add feature" not "Added feature")
- **Length**: 50 char subject, 72 char body
- **Co-authoring**: Include co-author lines when applicable
- **No force push** to main/master branches

### Pull Requests
- Squash commits when merging (project-specific)
- CI must pass
- Target `master` or `develop` (check repo)

## Source Generators

### Critical Rules
- **Reference as Analyzers**: `<ProjectReference OutputItemType="Analyzer" ReferenceOutputAssembly="false" />`
- **Never remove analyzer references** - builds fail silently
- **Debug generators**: Use `<EmitCompilerGeneratedFiles>true</EmitCompilerGeneratedFiles>`
- **Generated files**: In `obj/Debug/[framework]/generated/`

### Common Generator Patterns
- Attribute-based discovery (`[TypeCollection]`, `[ServiceTypeOption]`, etc.)
- Partial classes for augmentation
- Namespace matching for generated code

## Common Pitfalls

1. **Don't remove source generator references** - Silent build failures
2. **Don't use `DateTime.Now`** - Use `ISystemClock` or `DateTimeOffset.UtcNow`
3. **Don't catch `Exception`** - Catch specific types
4. **Don't use `Task.Result` or `.Wait()`** - Use `await`
5. **Don't return null** - Use `Option<T>`, `Result<T>`, or empty collections
6. **Don't use magic strings/numbers** - Use constants or configuration
7. **Don't ignore analyzer warnings** - Fix or suppress with justification

## Proactiveness Guidelines

### Ask First Before:
- Major architectural changes (changing layers, patterns)
- Deleting significant code (>50 lines)
- Changing public APIs (breaking changes)
- Adding new major dependencies
- Modifying CI/CD pipelines
- Force pushing or destructive git operations

### Just Do It:
- Implementing requested features
- Fixing obvious bugs
- Adding/updating tests
- Refactoring for clarity
- Updating documentation
- Adding XML docs
- Fixing compiler warnings
- Removing unused code

## Code Review Checklist

When reviewing code changes:
- [ ] Tests added/updated
- [ ] XML documentation on public APIs
- [ ] No magic strings/numbers
- [ ] Error handling appropriate (Result pattern, not exceptions)
- [ ] Logging for important operations
- [ ] No compiler warnings
- [ ] Nullable reference types handled correctly
- [ ] No obvious performance issues
- [ ] Follows project conventions

## Domain-Specific Patterns

### Enterprise Applications
- Services return `Result<T>` or `IGenericResult<T>`, not exceptions
- Commands use CQRS pattern when applicable
- Configuration uses strongly-typed classes
- Use dependency injection, not ServiceLocator

### Clean Architecture
- Dependencies point inward (Infrastructure → Core ← Api)
- Core has no external dependencies
- Use interfaces in Abstractions, implementations in Infrastructure

## Common Operations

### Creating New Project
```bash
# Create project
dotnet new classlib -n ProjectName.Feature

# Add to solution
dotnet sln add src/ProjectName.Feature/ProjectName.Feature.csproj

# Add references
cd src/ProjectName.Feature
dotnet add reference ../ProjectName.Core/ProjectName.Core.csproj
```

### Adding Package
```bash
# Always use dotnet CLI
dotnet add package PackageName

# Specific version
dotnet add package PackageName --version 1.2.3

# Check for updates
dotnet list package --outdated
```

### Running with specific configuration
```bash
dotnet build --configuration Release
dotnet test --configuration Alpha
```

## Notes

- This file applies to ALL C# projects globally
- Project-specific rules override these in each repo's `.claude/CLAUDE.md`
- Keep this updated as preferences evolve
- Check project's CLAUDE.md for repo-specific overrides (ServiceTypes, domain patterns, etc.)
