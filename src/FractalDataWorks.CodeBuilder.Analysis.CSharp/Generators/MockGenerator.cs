using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace FractalDataWorks.CodeBuilder.Analysis.CSharp.Generators;

/// <summary>
/// A simple mock generator that generates code for classes with the [GenerateCode] attribute.
/// </summary>
[Generator]
public class MockGenerator : IIncrementalGenerator
{
    private readonly string _attributeSource;

    /// <summary>
    /// Initializes a new instance of the <see cref="MockGenerator"/> class.
    /// </summary>
    /// <param name="attributeSource">The source code for the GenerateCode attribute.</param>
    public MockGenerator(string attributeSource)
    {
        _attributeSource = attributeSource;
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="MockGenerator"/> class with default attribute source.
    /// </summary>
    public MockGenerator()
        : this(DefaultAttributeSource)
    {
    }

    /// <summary>
    /// Gets the default source for the GenerateCode attribute.
    /// </summary>
    public static string DefaultAttributeSource => @"
using System;

namespace TestNamespace
{
    [AttributeUsage(AttributeTargets.Class, Inherited = false, AllowMultiple = false)]
    public sealed class GenerateCodeAttribute : Attribute
    {
    }
}";

    /// <inheritdoc/>
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Register attribute
        context.RegisterPostInitializationOutput(ctx =>
            ctx.AddSource("GenerateCodeAttribute.g.cs", _attributeSource));

        // Set up the syntax provider for class declarations with the attribute
        var syntaxProvider = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: (syntax, _) => syntax is ClassDeclarationSyntax,
                transform: (ctx, _) => ctx.Node as ClassDeclarationSyntax)
            .Where(node => node != null);

        // Register source output for each class
        context.RegisterSourceOutput(syntaxProvider, (ctx, classNode) =>
        {
            if (classNode == null)
            {
                return;
            }

            // Check if the class has the attribute
            var hasAttribute = false;
            foreach (var attrList in classNode.AttributeLists)
            {
                if (attrList.Attributes.Any(attr => attr.Name.ToString().Contains("GenerateCode")))
                {
                    hasAttribute = true;
                }

                if (hasAttribute)
                {
                    break;
                }
            }

            if (!hasAttribute)
            {
                return;
            }

            // Generate a new class with extra functionality
            var className = classNode.Identifier.Text;
            var namespaceName = GetContainingNamespace(classNode);

            var code = GenerateClassCode(className, namespaceName);
            ctx.AddSource($"{className}Generated.g.cs", code);
        });
    }

    private static string GetContainingNamespace(ClassDeclarationSyntax classNode)
    {
        // Find the namespace declaration
        var parent = classNode.Parent;
        while (parent != null &&
               parent is not NamespaceDeclarationSyntax &&
               parent is not FileScopedNamespaceDeclarationSyntax)
        {
            parent = parent.Parent;
        }

        return parent switch
        {
            NamespaceDeclarationSyntax nsDecl => nsDecl.Name.ToString(),
            FileScopedNamespaceDeclarationSyntax fsNsDecl => fsNsDecl.Name.ToString(),
            _ => "DefaultNamespace",
        };
    }

    private static string GenerateClassCode(string className, string namespaceName)
    {
        return $$"""
                 // <auto-generated/>

                 using System;

                 namespace {{namespaceName}}
                 {
                     /// <summary>
                     /// Generated implementation of {{className}}.
                     /// </summary>
                     public class {{className}}Generated
                     {
                         private readonly {{className}} _source;
                         
                         /// <summary>
                         /// Initializes a new instance of the <see cref="{{className}}Generated"/> class.
                         /// </summary>
                         /// <param name="source">The source instance.</param>
                         public {{className}}Generated({{className}} source)
                         {
                 		    _source = source ?? throw new ArgumentNullException(nameof(source));
                         }
                         
                         /// <summary>
                         /// Returns a string representation of the object.
                         /// </summary>
                         /// <returns>A string representation of the object.</returns>
                         public override string ToString()
                         {
                 		    return $"Generated wrapper for {_source}";
                         }
                     }
                 }
                 """;
    }
}