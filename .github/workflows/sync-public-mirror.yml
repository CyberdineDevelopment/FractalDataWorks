name: Sync Public Mirror (History Preserving)

on:
  push:
    branches:
      - master
      - develop
  workflow_dispatch:
    inputs:
      force_sync:
        description: 'Force full sync even if no changes detected'
        required: false
        default: 'false'

env:
  SYNC_STATE_FILE: '.sync-state.json'

jobs:
  sync:
    name: Sync to Public Repository with History
    runs-on: windows-latest

    steps:
      - name: Checkout private repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.PRIVATE_REPO_TOKEN }}

      - name: Discover public projects and tests
        id: discover
        shell: pwsh
        run: |
          Write-Host "Discovering projects to sync..." -ForegroundColor Cyan

          # Define exclusion patterns for projects that should NEVER be synced (blacklist)
          $excludePatterns = @(
            "*McpTools*",      # MCP tools - private only
            "*\.Mcp\.*",       # MCP projects
            "*\.MCP\.*",       # MCP projects (uppercase)
            "*SqlServer*",     # SQL Server implementations - private only
            "*\.Rest\.*"       # REST implementations - may have proprietary integrations
          )

          # Find all .csproj files (all projects will sync unless excluded by pattern)
          $projectFiles = Get-ChildItem -Path . -Filter "*.csproj" -Recurse -File |
            Where-Object { $_.FullName -notlike "*\bin\*" -and $_.FullName -notlike "*\obj\*" }

          $publicProjects = @()
          $testProjects = @()
          $excludedProjects = @()

          foreach ($projectFile in $projectFiles) {
            $relativePath = [System.IO.Path]::GetRelativePath((Get-Location), $projectFile.DirectoryName)
            $projectName = $projectFile.BaseName

            # Check if project matches any exclusion pattern
            $isExcluded = $false
            foreach ($pattern in $excludePatterns) {
              if ($projectName -like $pattern) {
                $isExcluded = $true
                $excludedProjects += $projectName
                Write-Host "  ⊘ $projectName (excluded by pattern: $pattern)" -ForegroundColor Yellow
                break
              }
            }

            if (-not $isExcluded) {
              $publicProjects += $relativePath

              # Look for corresponding test project
              $testProjectPath = "tests\$projectName.Tests"
              if (Test-Path $testProjectPath) {
                $testProjects += $testProjectPath
                Write-Host "  ✓ $projectName (with tests)" -ForegroundColor Green
              } else {
                Write-Host "  ✓ $projectName" -ForegroundColor Green
              }
            }
          }

          Write-Host ""
          Write-Host "Found $($publicProjects.Count) public projects"
          Write-Host "Found $($testProjects.Count) test projects"
          if ($excludedProjects.Count -gt 0) {
            Write-Host "Excluded $($excludedProjects.Count) projects by exclusion patterns" -ForegroundColor Yellow
          }

          # Save to files for later steps
          $publicProjects | Out-File -FilePath "$env:TEMP\public-projects.txt" -Encoding UTF8
          $testProjects | Out-File -FilePath "$env:TEMP\test-projects.txt" -Encoding UTF8

          # Output for summary
          echo "project_count=$($publicProjects.Count)" >> $env:GITHUB_OUTPUT
          echo "test_count=$($testProjects.Count)" >> $env:GITHUB_OUTPUT
          echo "excluded_count=$($excludedProjects.Count)" >> $env:GITHUB_OUTPUT

      - name: Checkout public repository
        uses: actions/checkout@v4
        with:
          repository: ${{ secrets.PUBLIC_REPO_NAME }}
          token: ${{ secrets.PUBLIC_REPO_TOKEN }}
          path: public-repo
          fetch-depth: 0

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          global-json-file: global.json

      - name: Configure Git
        run: |
          git config --global user.name "${{ github.event.head_commit.author.name }}"
          git config --global user.email "${{ github.event.head_commit.author.email }}"

      - name: Get commits since last sync
        id: commits
        shell: pwsh
        run: |
          $privateRepo = $PWD
          $publicRepo = Join-Path $PWD "public-repo"

          cd $publicRepo

          # Check if sync state file exists
          $syncStateFile = ".sync-state.json"
          $lastSyncSha = $null

          if (Test-Path $syncStateFile) {
            $syncState = Get-Content $syncStateFile | ConvertFrom-Json
            $lastSyncSha = $syncState.lastSyncedCommit
            Write-Host "Last synced commit: $lastSyncSha" -ForegroundColor Cyan
          } else {
            Write-Host "No previous sync state found - this is initial sync" -ForegroundColor Yellow
          }

          cd $privateRepo

          # Get commits since last sync
          if ($lastSyncSha) {
            $commits = git log --format="%H|%an|%ae|%at|%s" "$lastSyncSha..HEAD"
          } else {
            # Initial sync - only get current commit
            $commits = git log --format="%H|%an|%ae|%at|%s" -1
          }

          if ($commits) {
            $commits | Out-File -FilePath "$env:TEMP\commits-to-sync.txt" -Encoding UTF8
            $commitCount = ($commits | Measure-Object).Count
            Write-Host "Found $commitCount commits to sync" -ForegroundColor Green
            echo "commit_count=$commitCount" >> $env:GITHUB_OUTPUT
            echo "has_commits=true" >> $env:GITHUB_OUTPUT
          } else {
            Write-Host "No new commits to sync" -ForegroundColor Yellow
            echo "commit_count=0" >> $env:GITHUB_OUTPUT
            echo "has_commits=false" >> $env:GITHUB_OUTPUT
          }

      - name: Sync public projects with history
        if: steps.commits.outputs.has_commits == 'true'
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"

          $privateRepo = $PWD
          $publicRepo = Join-Path $PWD "public-repo"

          Write-Host "Private repo: $privateRepo" -ForegroundColor Cyan
          Write-Host "Public repo:  $publicRepo" -ForegroundColor Cyan
          Write-Host ""

          # Read public projects and tests
          $publicProjects = Get-Content "$env:TEMP\public-projects.txt"
          $testProjects = @()
          if (Test-Path "$env:TEMP\test-projects.txt") {
            $testProjects = Get-Content "$env:TEMP\test-projects.txt" | Where-Object { $_ }
          }

          # Read commits to process
          $commits = Get-Content "$env:TEMP\commits-to-sync.txt"

          Write-Host "Processing $($commits.Count) commits..." -ForegroundColor Cyan
          Write-Host ""

          foreach ($commitLine in $commits) {
            $parts = $commitLine -split '\|'
            $commitSha = $parts[0]
            $authorName = $parts[1]
            $authorEmail = $parts[2]
            $commitTime = $parts[3]
            $commitMessage = $parts[4..($parts.Length - 1)] -join '|'

            Write-Host "Processing commit: $commitSha" -ForegroundColor White
            Write-Host "  Author: $authorName <$authorEmail>"
            Write-Host "  Message: $commitMessage"

            # Check if this commit touches any public paths
            $changedFiles = git diff-tree --no-commit-id --name-only -r $commitSha
            $touchesPublic = $false

            foreach ($file in $changedFiles) {
              foreach ($publicPath in $publicProjects) {
                if ($file -like "$publicPath/*") {
                  $touchesPublic = $true
                  break
                }
              }
              if ($touchesPublic) { break }

              foreach ($testPath in $testProjects) {
                if ($file -like "$testPath/*") {
                  $touchesPublic = $true
                  break
                }
              }
              if ($touchesPublic) { break }
            }

            if (-not $touchesPublic) {
              Write-Host "  ⊘ Skipping (no public changes)" -ForegroundColor Gray
              continue
            }

            Write-Host "  ✓ Syncing (touches public projects)" -ForegroundColor Green

            # Clean and copy public projects
            cd $publicRepo
            Get-ChildItem -Exclude ".git",".github" | Remove-Item -Recurse -Force -ErrorAction SilentlyContinue

            cd $privateRepo

            # Copy public projects
            foreach ($projectPath in $publicProjects) {
              $sourcePath = Join-Path $privateRepo $projectPath
              $destPath = Join-Path $publicRepo $projectPath

              if (Test-Path $sourcePath) {
                $destParent = Split-Path $destPath -Parent
                if (-not (Test-Path $destParent)) {
                  New-Item -ItemType Directory -Path $destParent -Force | Out-Null
                }
                Copy-Item -Path $sourcePath -Destination $destPath -Recurse -Force
              }
            }

            # Copy test projects
            foreach ($testPath in $testProjects) {
              $sourcePath = Join-Path $privateRepo $testPath
              $destPath = Join-Path $publicRepo $testPath

              if (Test-Path $sourcePath) {
                $destParent = Split-Path $destPath -Parent
                if (-not (Test-Path $destParent)) {
                  New-Item -ItemType Directory -Path $destParent -Force | Out-Null
                }
                Copy-Item -Path $sourcePath -Destination $destPath -Recurse -Force
              }
            }

            # Copy root configuration files
            $rootFiles = @(
              ".editorconfig",
              ".gitignore",
              "Directory.Build.props",
              "Directory.Packages.props",
              "PublicProjects.props",
              "coverlet.runsettings",
              "global.json",
              "LICENSE",
              "NOTICE",
              "nuget.config",
              "version.json",
              "xunit.runner.json"
            )

            foreach ($file in $rootFiles) {
              $sourcePath = Join-Path $privateRepo $file
              $destPath = Join-Path $publicRepo $file

              if (Test-Path $sourcePath) {
                Copy-Item -Path $sourcePath -Destination $destPath -Force
              }
            }

            # Create commit in public repo with original metadata
            cd $publicRepo

            git add -A

            $hasChanges = git status --porcelain
            if ($hasChanges) {
              # Set author and committer to original
              $env:GIT_AUTHOR_NAME = $authorName
              $env:GIT_AUTHOR_EMAIL = $authorEmail
              $env:GIT_AUTHOR_DATE = (Get-Date -UnixTimeSeconds $commitTime).ToString("yyyy-MM-ddTHH:mm:sszzz")
              $env:GIT_COMMITTER_NAME = $authorName
              $env:GIT_COMMITTER_EMAIL = $authorEmail
              $env:GIT_COMMITTER_DATE = $env:GIT_AUTHOR_DATE

              git commit -m $commitMessage
              Write-Host "  ✓ Committed to public repo" -ForegroundColor Green
            } else {
              Write-Host "  ⊘ No changes to commit" -ForegroundColor Gray
            }

            cd $privateRepo
          }

      - name: Generate solution file
        if: steps.commits.outputs.has_commits == 'true'
        shell: pwsh
        run: |
          cd public-repo

          Write-Host "Creating public solution file..." -ForegroundColor Cyan

          # Remove old solution if exists
          if (Test-Path "FractalDataWorks.sln") {
            Remove-Item "FractalDataWorks.sln" -Force
          }

          # Create new solution
          dotnet new sln -n "FractalDataWorks" | Out-Null

          # Find all .csproj files and add to solution
          $projects = Get-ChildItem -Path . -Filter "*.csproj" -Recurse -File |
            Where-Object { $_.FullName -notlike "*\bin\*" -and $_.FullName -notlike "*\obj\*" }

          $added = 0
          foreach ($proj in $projects) {
            Write-Host "  Adding: $($proj.BaseName)" -ForegroundColor White
            dotnet sln add $proj.FullName 2>&1 | Out-Null
            if ($LASTEXITCODE -eq 0) { $added++ }
          }

          Write-Host ""
          Write-Host "✓ Created FractalDataWorks.sln with $added projects" -ForegroundColor Green

      - name: Generate README index
        if: steps.commits.outputs.has_commits == 'true'
        shell: pwsh
        run: |
          cd public-repo

          Write-Host "Generating README index..." -ForegroundColor Cyan

          # Find all project folders in src
          $projectDirs = Get-ChildItem -Path "src" -Directory -ErrorAction SilentlyContinue | Sort-Object Name

          # Build README content
          $readme = @"
# FractalDataWorks Platform

Open-source .NET framework for service-oriented applications with Railway-Oriented Programming, advanced source generation, and type-safe extensibility.

## Packages

"@

          foreach ($dir in $projectDirs) {
            $readmePath = Join-Path $dir.FullName "README.md"
            if (Test-Path $readmePath) {
              $relativePath = [System.IO.Path]::GetRelativePath((Get-Location), $readmePath)
              $projectName = $dir.Name
              $readme += "- [**$projectName**]($($relativePath -replace '\\','/'))`n"
            }
          }

          $readme += @"

## Tests

All public projects include comprehensive test coverage in the tests directory.

## Documentation

Documentation is included in each project's README.

## Getting Started

Install packages from NuGet.org:

````
dotnet add package FractalDataWorks.Results
dotnet add package FractalDataWorks.Collections
dotnet add package FractalDataWorks.Services
````

## License

Apache 2.0 - see [LICENSE](LICENSE) for details.

## Links

- [GitHub Repository](https://github.com/CyberdineDevelopment/FractalDataWorks-Platform)
- [NuGet Packages](https://www.nuget.org/profiles/CyberdineDevelopment)
"@

          # Write README
          Set-Content -Path "README.md" -Value $readme -NoNewline
          Write-Host "✓ Generated README.md with project index" -ForegroundColor Green

          # Add README to git
          git add README.md

      - name: Sync public repo workflows
        if: steps.commits.outputs.has_commits == 'true'
        shell: pwsh
        run: |
          $privateRepo = $PWD
          $publicRepo = Join-Path $PWD "public-repo"

          Write-Host "Syncing GitHub workflows for public repo..." -ForegroundColor Cyan

          # Create .github/workflows directory in public repo
          $workflowDir = Join-Path $publicRepo ".github" "workflows"
          if (-not (Test-Path $workflowDir)) {
            New-Item -ItemType Directory -Path $workflowDir -Force | Out-Null
          }

          # Copy the NuGet.org publish workflow
          $nugetOrgWorkflow = Join-Path $privateRepo ".github" "workflows" "publish-nuget-org.yml"
          if (Test-Path $nugetOrgWorkflow) {
            Copy-Item -Path $nugetOrgWorkflow -Destination (Join-Path $workflowDir "publish-nuget.yml") -Force
            Write-Host "  ✓ publish-nuget.yml (for NuGet.org)" -ForegroundColor Green
          }

          # Copy CI workflow
          $ciWorkflow = Join-Path $privateRepo ".github" "workflows" "ci.yml"
          if (Test-Path $ciWorkflow) {
            Copy-Item -Path $ciWorkflow -Destination (Join-Path $workflowDir "ci.yml") -Force
            Write-Host "  ✓ ci.yml" -ForegroundColor Green
          }

          cd $publicRepo
          git add .github/

      - name: Update project URLs for public repo
        if: steps.commits.outputs.has_commits == 'true'
        shell: pwsh
        run: |
          cd public-repo

          Write-Host "Updating PackageProjectUrl in all projects..." -ForegroundColor Cyan

          $publicRepoUrl = "https://github.com/CyberdineDevelopment/FractalDataWorks-Platform"
          $projects = Get-ChildItem -Path . -Filter "*.csproj" -Recurse -File |
            Where-Object { $_.FullName -notlike "*\bin\*" -and $_.FullName -notlike "*\obj\*" }

          $updated = 0
          foreach ($proj in $projects) {
            $content = Get-Content $proj.FullName -Raw

            # Remove existing PackageProjectUrl if present
            $content = $content -replace '<PackageProjectUrl>.*?</PackageProjectUrl>\s*', ''

            # Add PackageProjectUrl after first PropertyGroup opening tag
            if ($content -match '(<PropertyGroup>\s*)') {
              if ($content -notmatch "<PackageProjectUrl>$([regex]::Escape($publicRepoUrl))</PackageProjectUrl>") {
                $content = $content -replace '(<PropertyGroup>\s*\r?\n)', "`$1    <PackageProjectUrl>$publicRepoUrl</PackageProjectUrl>`n"
                Set-Content -Path $proj.FullName -Value $content -NoNewline
                Write-Host "  ✓ $($proj.BaseName)" -ForegroundColor Green
                $updated++
              }
            }
          }

          Write-Host ""
          Write-Host "✓ Updated $updated projects with public repo URL" -ForegroundColor Green

          git add *.csproj

      - name: Update sync state
        if: steps.commits.outputs.has_commits == 'true'
        shell: pwsh
        run: |
          cd public-repo

          $latestCommitSha = "${{ github.sha }}"

          $syncState = @{
            lastSyncedCommit = $latestCommitSha
            syncedAt = (Get-Date).ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ssZ")
            syncedBy = "${{ github.actor }}"
            branch = "${{ github.ref_name }}"
          }

          $syncState | ConvertTo-Json | Set-Content -Path "$env:SYNC_STATE_FILE" -NoNewline

          git add "$env:SYNC_STATE_FILE"

          Write-Host "✓ Updated sync state to commit $latestCommitSha" -ForegroundColor Green

      - name: Commit metadata changes
        if: steps.commits.outputs.has_commits == 'true'
        shell: pwsh
        run: |
          cd public-repo

          $hasChanges = git status --porcelain
          if ($hasChanges) {
            git commit -m "Update metadata (solution, README, workflows, sync state)

Automated update for public repository
Branch: ${{ github.ref_name }}
Private commit: ${{ github.sha }}"

            Write-Host "✓ Committed metadata changes" -ForegroundColor Green
          }

      - name: Push to public repository
        if: steps.commits.outputs.has_commits == 'true'
        shell: pwsh
        run: |
          cd public-repo

          $branch = "${{ github.ref_name }}"
          git push origin HEAD:$branch

          Write-Host "✓ Changes pushed to public repository branch: $branch" -ForegroundColor Green

      - name: Summary
        shell: pwsh
        run: |
          $summary = @"
          ### Public Mirror Sync Complete ✓

          **Branch:** ${{ github.ref_name }}
          **Commit:** ``${{ github.sha }}``
          **Projects synced:** ${{ steps.discover.outputs.project_count }}
          **Tests synced:** ${{ steps.discover.outputs.test_count }}
          **Projects excluded:** ${{ steps.discover.outputs.excluded_count }}
          **Commits processed:** ${{ steps.commits.outputs.commit_count }}

          Public repository has been updated with commit history preserved.
          Excluded projects: MCP tools, SQL Server implementations, REST implementations.
          "@

          $summary | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding UTF8
